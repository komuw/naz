<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.1" />
<title>naz.client API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id=^header-]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:1px solid #ddd;margin:1em 0 1em 4ch}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}#index .two-column{column-count:2}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{background:#ffc;font-weight:400;font-size:.8em;width:11em;text-transform:uppercase;padding:0px 8px;border:1px solid #fd6;border-radius:5px;cursor:pointer}.source summary:hover{background:#fe9 !important}.source[open] summary{background:#fda}.source pre{max-height:500px;overflow-y:scroll;margin-bottom:15px}.hlist{list-syle:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink;]</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>naz.client</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import struct
import random
import string
import typing
import asyncio
import logging

from . import hooks
from . import nazcodec
from . import sequence
from . import throttle
from . import correlater
from . import ratelimiter


class Client:
    &#34;&#34;&#34;
    &#34;&#34;&#34;

    def __init__(
        self,
        async_loop,
        smsc_host,
        smsc_port,
        system_id,
        password,
        outboundqueue,
        client_id=None,
        system_type=&#34;&#34;,
        addr_ton=0,
        addr_npi=0,
        address_range=&#34;&#34;,
        encoding=&#34;gsm0338&#34;,
        interface_version=34,
        service_type=&#34;CMT&#34;,  # section 5.2.11
        source_addr_ton=0x00000001,  # section 5.2.5
        source_addr_npi=0x00000001,
        dest_addr_ton=0x00000001,
        dest_addr_npi=0x00000001,
        # xxxxxx00 store-and-forward
        # xx0010xx Short Message contains ESME Delivery Acknowledgement
        # 00xxxxxx No specific features selected
        esm_class=0b00000011,  # section 5.2.12
        protocol_id=0x00000000,
        priority_flag=0x00000000,
        schedule_delivery_time=&#34;&#34;,
        validity_period=&#34;&#34;,
        # xxxxxx01 SMSC Delivery Receipt requested where final delivery outcome is delivery success or failure
        # xxxx01xx SME Delivery Acknowledgement requested
        # xxx0xxxx No Intermediate notification requested
        # all other values reserved
        registered_delivery=0b00000001,  # see section 5.2.17
        replace_if_present_flag=0x00000000,
        sm_default_msg_id=0x00000000,
        enquire_link_interval=300,
        loglevel=&#34;DEBUG&#34;,
        log_metadata=None,
        codec_class=None,
        codec_errors_level=&#34;strict&#34;,
        rateLimiter=None,
        hook=None,
        sequence_generator=None,
        throttle_handler=None,
        correlation_handler=None,
    ):
        &#34;&#34;&#34;
        todo: add docs
        &#34;&#34;&#34;
        if loglevel.upper() not in [&#34;DEBUG&#34;, &#34;INFO&#34;, &#34;WARNING&#34;, &#34;ERROR&#34;, &#34;CRITICAL&#34;]:
            raise ValueError(
                &#34;&#34;&#34;loglevel should be one of; &#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARNING&#39;, &#39;ERROR&#39; or &#39;CRITICAL&#39;. not {0}&#34;&#34;&#34;.format(
                    loglevel
                )
            )
        elif not isinstance(log_metadata, (type(None), dict)):
            raise ValueError(
                &#34;&#34;&#34;log_metadata should be of type:: None or dict. You entered {0}&#34;&#34;&#34;.format(
                    type(log_metadata)
                )
            )

        # this allows people to pass in their own event loop eg uvloop.
        self.async_loop = async_loop
        self.smsc_host = smsc_host
        self.smsc_port = smsc_port
        self.system_id = system_id
        self.password = password
        self.outboundqueue = outboundqueue
        self.client_id = client_id
        if not self.client_id:
            self.client_id = &#34;&#34;.join(random.choices(string.ascii_uppercase + string.digits, k=17))
        self.system_type = system_type
        self.interface_version = interface_version
        self.addr_ton = addr_ton
        self.addr_npi = addr_npi
        self.address_range = address_range
        self.encoding = encoding

        self.sequence_generator = sequence_generator
        if not self.sequence_generator:
            self.sequence_generator = sequence.SimpleSequenceGenerator()

        self.max_sequence_number = 0x7FFFFFFF
        self.loglevel = loglevel.upper()
        self.log_metadata = log_metadata
        if not self.log_metadata:
            self.log_metadata = {}
        self.log_metadata.update(
            {&#34;smsc_host&#34;: self.smsc_host, &#34;system_id&#34;: system_id, &#34;client_id&#34;: self.client_id}
        )

        self.codec_errors_level = codec_errors_level
        self.codec_class = codec_class
        if not self.codec_class:
            self.codec_class = nazcodec.SimpleNazCodec(errors=self.codec_errors_level)

        self.service_type = service_type
        self.source_addr_ton = source_addr_ton
        self.source_addr_npi = source_addr_npi
        self.dest_addr_ton = dest_addr_ton
        self.dest_addr_npi = dest_addr_npi
        self.esm_class = esm_class
        self.protocol_id = protocol_id
        self.priority_flag = priority_flag
        self.schedule_delivery_time = schedule_delivery_time
        self.validity_period = validity_period
        self.registered_delivery = registered_delivery
        self.replace_if_present_flag = replace_if_present_flag
        self.sm_default_msg_id = sm_default_msg_id
        self.enquire_link_interval = enquire_link_interval

        # see section 5.1.2.1 of smpp ver 3.4 spec document
        self.command_ids = {
            SmppCommand.BIND_TRANSCEIVER: 0x00000009,
            SmppCommand.BIND_TRANSCEIVER_RESP: 0x80000009,
            SmppCommand.UNBIND: 0x00000006,
            SmppCommand.UNBIND_RESP: 0x80000006,
            SmppCommand.SUBMIT_SM: 0x00000004,
            SmppCommand.SUBMIT_SM_RESP: 0x80000004,
            SmppCommand.DELIVER_SM: 0x00000005,
            SmppCommand.DELIVER_SM_RESP: 0x80000005,
            SmppCommand.ENQUIRE_LINK: 0x00000015,
            SmppCommand.ENQUIRE_LINK_RESP: 0x80000015,
            SmppCommand.GENERIC_NACK: 0x80000000,
        }

        self.data_coding = self.find_data_coding(self.encoding)

        self.reader = None
        self.writer = None

        # NB: currently, naz only uses to log levels; INFO and EXCEPTION
        extra_log_data = {&#34;log_metadata&#34;: self.log_metadata}
        self.logger = logging.getLogger(&#34;naz.client&#34;)
        handler = logging.StreamHandler()
        formatter = logging.Formatter(&#34;%(message)s&#34;)
        handler.setFormatter(formatter)
        if not self.logger.handlers:
            self.logger.addHandler(handler)
        self.logger.setLevel(self.loglevel)
        self.logger = NazLoggingAdapter(self.logger, extra_log_data)

        self.rateLimiter = rateLimiter
        if not self.rateLimiter:
            self.rateLimiter = ratelimiter.SimpleRateLimiter(logger=self.logger)

        self.hook = hook
        if not self.hook:
            self.hook = hooks.SimpleHook(logger=self.logger)

        self.throttle_handler = throttle_handler
        if not self.throttle_handler:
            self.throttle_handler = throttle.SimpleThrottleHandler(logger=self.logger)

        # class storing SMPP sequence_number and their corresponding log_id and/or hook_metadata
        # this will be used to track different pdu&#39;s and user generated log_id
        self.correlation_handler = correlation_handler
        if not self.correlation_handler:
            self.correlation_handler = correlater.SimpleCorrelater()

        # the messages that are published to a queue by either naz
        # or user application should be versioned.
        # This version will enable naz to be able to evolve in future;
        # eg a future version of naz could add/remove the number of required items in a message.
        # This is a bit similar to: http://docs.celeryproject.org/en/latest/internals/protocol.html
        self.naz_message_protocol_version = &#34;1&#34;

        self.current_session_state = SmppSessionState.CLOSED

    @staticmethod
    def find_data_coding(encoding):
        for key, val in SmppDataCoding.__dict__.items():
            if not key.startswith(&#34;__&#34;):
                if encoding == val.code:
                    return val.value
        raise ValueError(&#34;That encoding:{0} is not recognised.&#34;.format(encoding))

    def search_by_command_id_code(self, command_id_code):
        for key, val in self.command_ids.items():
            if val == command_id_code:
                return key
        return None

    @staticmethod
    def search_by_command_status_value(command_status_value):
        # TODO: find a cheaper(better) way of doing this
        for key, val in SmppCommandStatus.__dict__.items():
            if not key.startswith(&#34;__&#34;):
                if command_status_value == val.value:
                    return val
        return None

    @staticmethod
    def retry_after(current_retries):
        &#34;&#34;&#34;
        retries will happen in this sequence;
        1min, 2min, 4min, 8min, 16min, 32min, 16min, 16min, 16min ...
        &#34;&#34;&#34;
        # TODO:
        # 1. give users ability to bring their own retry algorithms.
        # 2. add jitter
        if current_retries &lt; 0:
            current_retries = 0
        if current_retries &gt;= 6:
            return 60 * 16  # 16 minutes
        else:
            return 60 * (1 * (2 ** current_retries))

    async def connect(self):
        self.logger.info({&#34;event&#34;: &#34;naz.Client.connect&#34;, &#34;stage&#34;: &#34;start&#34;})
        reader, writer = await asyncio.open_connection(
            self.smsc_host, self.smsc_port, loop=self.async_loop
        )
        self.reader = reader
        self.writer = writer
        self.logger.info({&#34;event&#34;: &#34;naz.Client.connect&#34;, &#34;stage&#34;: &#34;end&#34;})
        self.current_session_state = SmppSessionState.OPEN
        return reader, writer

    async def tranceiver_bind(self):
        smpp_command = SmppCommand.BIND_TRANSCEIVER
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        # body
        body = b&#34;&#34;
        body = (
            body
            + self.codec_class.encode(self.system_id, self.encoding)
            + chr(0).encode()
            + self.codec_class.encode(self.password, self.encoding)
            + chr(0).encode()
            + self.codec_class.encode(self.system_type, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;I&#34;, self.interface_version)
            + struct.pack(&#34;&gt;I&#34;, self.addr_ton)
            + struct.pack(&#34;&gt;I&#34;, self.addr_npi)
            + self.codec_class.encode(self.address_range, self.encoding)
            + chr(0).encode()
        )

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        # the status for success see section 5.1.3
        command_status = SmppCommandStatus.ESME_ROK.value
        try:
            sequence_number = self.sequence_generator.next_sequence()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;smpp_command&#34;: smpp_command,
                }
            )

        if sequence_number &gt; self.max_sequence_number:
            # prevent third party sequence_generators from ruining our party
            raise ValueError(
                &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                    sequence_number, self.max_sequence_number
                )
            )

        # associate sequence_number with log_id.
        # this will enable us to also associate responses and thus enhancing traceability of all workflows
        try:
            await self.correlation_handler.put(
                sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater put error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
        full_pdu = header + body
        await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        return full_pdu

    async def enquire_link(self, TESTING=False):
        &#34;&#34;&#34;
        HEADER::
        # enquire_link has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `enquire_link`
        command_status, int, 4octet. Not used. Set to NULL
        sequence_number, int, 4octet.

        `enquire_link` has no body.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.ENQUIRE_LINK
        while True:
            if self.current_session_state != SmppSessionState.BOUND_TRX:
                # you can only send enquire_link request when session state is BOUND_TRX
                await asyncio.sleep(self.enquire_link_interval)

            log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
            # body
            body = b&#34;&#34;

            # header
            command_length = 16 + len(body)  # 16 is for headers
            command_id = self.command_ids[smpp_command]
            command_status = 0x00000000  # not used for `enquire_link`
            try:
                sequence_number = self.sequence_generator.next_sequence()
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;error&#34;: str(e),
                        &#34;log_id&#34;: log_id,
                        &#34;smpp_command&#34;: smpp_command,
                    }
                )
            if sequence_number &gt; self.max_sequence_number:
                # prevent third party sequence_generators from ruining our party
                raise ValueError(
                    &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                        sequence_number, self.max_sequence_number
                    )
                )

            try:
                await self.correlation_handler.put(
                    sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
                )
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;smpp_command&#34;: smpp_command,
                        &#34;log_id&#34;: log_id,
                        &#34;state&#34;: &#34;correlater put error&#34;,
                        &#34;error&#34;: str(e),
                    }
                )

            header = struct.pack(
                &#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number
            )
            full_pdu = header + body
            # dont queue enquire_link in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
            await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
            if TESTING:
                return full_pdu
            await asyncio.sleep(self.enquire_link_interval)

    async def enquire_link_resp(self, sequence_number):
        &#34;&#34;&#34;
        HEADER::
        # enquire_link_resp has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `enquire_link_resp`
        command_status, int, 4octet. ESME_ROK (Success)
        sequence_number, int, 4octet. Set to the same sequence number of original `enquire_link` PDU

        `enquire_link_resp` has no body.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.ENQUIRE_LINK_RESP
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

        # body
        body = b&#34;&#34;

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = SmppCommandStatus.ESME_ROK.value
        sequence_number = sequence_number
        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

        full_pdu = header + body
        item_to_enqueue = {
            &#34;version&#34;: self.naz_message_protocol_version,
            &#34;log_id&#34;: log_id,
            &#34;pdu&#34;: full_pdu,
            &#34;smpp_command&#34;: smpp_command,
        }
        try:
            await self.outboundqueue.enqueue(item_to_enqueue)
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    async def unbind_resp(self, sequence_number):
        &#34;&#34;&#34;
        HEADER::
        # unbind_resp has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `unbind_resp`
        command_status, int, 4octet. Indicates outcome of original unbind request, eg ESME_ROK (Success)
        sequence_number, int, 4octet. Set to the same sequence number of original `unbind` PDU

        `unbind_resp` has no body.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.UNBIND_RESP
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind_resp&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

        # body
        body = b&#34;&#34;

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = SmppCommandStatus.ESME_ROK.value
        sequence_number = sequence_number
        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

        full_pdu = header + body
        # dont queue unbind_resp in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
        await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    async def deliver_sm_resp(self, sequence_number):
        &#34;&#34;&#34;
        HEADER::
        # deliver_sm_resp has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `deliver_sm_resp`
        command_status, int, 4octet. Indicates outcome of deliver_sm request, eg. ESME_ROK (Success)
        sequence_number, int, 4octet.  Set to the same sequence_number of `deliver_sm` PDU.

        BODY::
        message_id, c-octet String, 1octet. This field is unused and is set to NULL.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.DELIVER_SM_RESP
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        # body
        body = b&#34;&#34;
        message_id = &#34;&#34;
        body = body + self.codec_class.encode(message_id, self.encoding) + chr(0).encode()

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = SmppCommandStatus.ESME_ROK.value
        sequence_number = sequence_number
        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

        full_pdu = header + body
        item_to_enqueue = {
            &#34;version&#34;: self.naz_message_protocol_version,
            &#34;log_id&#34;: log_id,
            &#34;pdu&#34;: full_pdu,
            &#34;smpp_command&#34;: smpp_command,
        }
        try:
            await self.outboundqueue.enqueue(item_to_enqueue)
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )

        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    # this method just enqueues a submit_sm msg to queue
    async def submit_sm(self, short_message, log_id, source_addr, destination_addr):
        &#34;&#34;&#34;
        HEADER::
        # submit_sm has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `submit_sm`
        command_status, int, 4octet. Not used. Set to NULL
        sequence_number, int, 4octet.  The associated submit_sm_resp PDU will echo this sequence number.

        BODY::
        # submit_sm has the following pdu body. NB: They SHOULD be put in the body in the ORDER presented here.
        # service_type, c-octet str, max 6octet. eg NULL, &#34;USSD&#34;, &#34;CMT&#34; etc
        # source_addr_ton, int , 1octet,
        # source_addr_npi, int, 1octet
        # source_addr, c-octet str, max 21octet. eg; This is usually the senders phone Number
        # dest_addr_ton, int, 1octet
        # dest_addr_npi, int, 1octet
        # destination_addr,  C-Octet String, max 21 octet. eg; This is usually the recipients phone Number
        # esm_class, int, 1octet
        # protocol_id, int, 1octet
        # priority_flag, int, 1octet
        # schedule_delivery_time, c-octet str, 1 or 17 octets. NULL for immediate message delivery.
        # validity_period, c-octet str, 1 or 17 octets.  NULL for SMSC default.
        # registered_delivery, int, 1octet
        # replace_if_present_flag, int, 1octet
        # data_coding, int, 1octet. Defines the encoding scheme of the short message user data. Bits 7 6 5 4 3 2 1 0
        # sm_default_msg_id, int, 1octet. SMSC index of a pre-defined(`canned`) message.  If not using an SMSC canned message, set to NULL
        # sm_length, int, 1octet. Length in octets of the `short_message`.
        # short_message, Octet-String(NOT c-octet str), 0-254 octets.
        NB: 1. Applications which need to send messages longer than 254 octets should use the `message_payload` optional parameter.
               In this case the `sm_length` field should be set to zero
               u cant use both `short_message` and `message_payload`
            2. Octet String - A series of octets, not necessarily NULL terminated.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.SUBMIT_SM
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        item_to_enqueue = {
            &#34;version&#34;: self.naz_message_protocol_version,
            &#34;smpp_command&#34;: smpp_command,
            &#34;short_message&#34;: short_message,
            &#34;log_id&#34;: log_id,
            &#34;source_addr&#34;: source_addr,
            &#34;destination_addr&#34;: destination_addr,
        }
        try:
            await self.outboundqueue.enqueue(item_to_enqueue)
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    async def build_submit_sm_pdu(
        self, short_message, log_id, hook_metadata, source_addr, destination_addr
    ):
        smpp_command = SmppCommand.SUBMIT_SM
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        encoded_short_message = self.codec_class.encode(short_message, self.encoding)
        sm_length = len(encoded_short_message)

        # body
        body = b&#34;&#34;
        body = (
            body
            + self.codec_class.encode(self.service_type, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.source_addr_ton)
            + struct.pack(&#34;&gt;B&#34;, self.source_addr_npi)
            + self.codec_class.encode(source_addr, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.dest_addr_ton)
            + struct.pack(&#34;&gt;B&#34;, self.dest_addr_npi)
            + self.codec_class.encode(destination_addr, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.esm_class)
            + struct.pack(&#34;&gt;B&#34;, self.protocol_id)
            + struct.pack(&#34;&gt;B&#34;, self.priority_flag)
            + self.codec_class.encode(self.schedule_delivery_time, self.encoding)
            + chr(0).encode()
            + self.codec_class.encode(self.validity_period, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.registered_delivery)
            + struct.pack(&#34;&gt;B&#34;, self.replace_if_present_flag)
            + struct.pack(&#34;&gt;B&#34;, self.data_coding)
            + struct.pack(&#34;&gt;B&#34;, self.sm_default_msg_id)
            + struct.pack(&#34;&gt;B&#34;, sm_length)
            + self.codec_class.encode(short_message, self.encoding)
        )

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        # the status for success see section 5.1.3
        command_status = 0x00000000  # not used for `submit_sm`
        try:
            sequence_number = self.sequence_generator.next_sequence()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        if sequence_number &gt; self.max_sequence_number:
            # prevent third party sequence_generators from ruining our party
            raise ValueError(
                &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                    sequence_number, self.max_sequence_number
                )
            )

        try:
            await self.correlation_handler.put(
                sequence_number=sequence_number, log_id=log_id, hook_metadata=hook_metadata
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater put error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
        full_pdu = header + body
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        return full_pdu

    async def send_data(self, smpp_command, msg, log_id, hook_metadata=&#34;&#34;):
        &#34;&#34;&#34;
        This method does not block; it buffers the data and arranges for it to be sent out asynchronously.
        see: https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write
        &#34;&#34;&#34;
        # todo: look at `set_write_buffer_limits` and `get_write_buffer_limits` methods
        # print(&#34;get_write_buffer_limits:&#34;, writer.transport.get_write_buffer_limits())

        log_msg = &#34;&#34;
        try:
            log_msg = self.codec_class.decode(msg, self.encoding)
            # do not log password, redact it from logs.
            if self.password in log_msg:
                log_msg = log_msg.replace(self.password, &#34;{REDACTED}&#34;)
        except Exception:
            pass
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;msg&#34;: log_msg,
            }
        )

        # check session state to see if we can send messages.
        # see section 2.3 of SMPP spec document v3.4
        if self.current_session_state == SmppSessionState.CLOSED:
            error_msg = &#34;smpp_command: {0} cannot be sent to SMSC when the client session state is: {1}&#34;.format(
                smpp_command, self.current_session_state
            )
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;msg&#34;: log_msg,
                    &#34;current_session_state&#34;: self.current_session_state,
                    &#34;error&#34;: error_msg,
                }
            )
            raise ValueError(error_msg)
        elif self.current_session_state == SmppSessionState.OPEN and smpp_command not in [
            &#34;bind_transmitter&#34;,
            &#34;bind_receiver&#34;,
            &#34;bind_transceiver&#34;,
        ]:
            # only the smpp_command&#39;s listed above are allowed by SMPP spec to be sent
            # if current_session_state == SmppSessionState.OPEN
            error_msg = &#34;smpp_command: {0} cannot be sent to SMSC when the client session state is: {1}&#34;.format(
                smpp_command, self.current_session_state
            )
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;msg&#34;: log_msg,
                    &#34;current_session_state&#34;: self.current_session_state,
                    &#34;error&#34;: error_msg,
                }
            )
            raise ValueError(error_msg)

        if isinstance(msg, str):
            msg = self.codec_class.encode(msg, self.encoding)

        # call user&#39;s hook for requests
        try:
            await self.hook.request(
                smpp_command=smpp_command, log_id=log_id, hook_metadata=hook_metadata
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;request hook error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        # We use writer.drain() which is a flow control method that interacts with the IO write buffer.
        # When the size of the buffer reaches the high watermark,
        # drain blocks until the size of the buffer is drained down to the low watermark and writing can be resumed.
        # When there is nothing to wait for, the drain() returns immediately.
        # ref: https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.drain
        self.writer.write(msg)
        await self.writer.drain()
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;msg&#34;: log_msg,
            }
        )

    async def send_forever(self, TESTING=False):
        retry_count = 0
        while True:
            self.logger.info({&#34;event&#34;: &#34;naz.Client.send_forever&#34;, &#34;stage&#34;: &#34;start&#34;})

            # TODO: there are so many try-except classes in this func.
            # do something about that.
            try:
                # check with throttle handler
                send_request = await self.throttle_handler.allow_request()
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;state&#34;: &#34;send_forever error&#34;,
                        &#34;error&#34;: str(e),
                    }
                )
                continue
            if send_request:
                try:
                    # rate limit ourselves
                    await self.rateLimiter.limit()
                except Exception as e:
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error&#34;,
                            &#34;error&#34;: str(e),
                        }
                    )
                    continue

                try:
                    item_to_dequeue = await self.outboundqueue.dequeue()
                except Exception as e:
                    retry_count += 1
                    poll_queue_interval = self.retry_after(retry_count)
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error. sleeping for {0}minutes&#34;.format(
                                poll_queue_interval / 60
                            ),
                            &#34;retry_count&#34;: retry_count,
                            &#34;error&#34;: str(e),
                        }
                    )
                    await asyncio.sleep(poll_queue_interval)
                    continue
                # we didn&#39;t fail to dequeue a message
                retry_count = 0
                try:
                    log_id = item_to_dequeue[&#34;log_id&#34;]
                    item_to_dequeue[&#34;version&#34;]  # version is a required field
                    smpp_command = item_to_dequeue[&#34;smpp_command&#34;]
                    hook_metadata = item_to_dequeue.get(&#34;hook_metadata&#34;, &#34;&#34;)
                    if smpp_command == SmppCommand.SUBMIT_SM:
                        short_message = item_to_dequeue[&#34;short_message&#34;]
                        source_addr = item_to_dequeue[&#34;source_addr&#34;]
                        destination_addr = item_to_dequeue[&#34;destination_addr&#34;]
                        full_pdu = await self.build_submit_sm_pdu(
                            short_message, log_id, hook_metadata, source_addr, destination_addr
                        )
                    else:
                        full_pdu = item_to_dequeue[&#34;pdu&#34;]
                except KeyError as e:
                    e = KeyError(
                        &#34;enqueued message/object is missing required field:{}&#34;.format(str(e))
                    )
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error&#34;,
                            &#34;error&#34;: str(e),
                        }
                    )
                    continue

                await self.send_data(
                    smpp_command=smpp_command,
                    msg=full_pdu,
                    log_id=log_id,
                    hook_metadata=hook_metadata,
                )
                self.logger.info(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;log_id&#34;: log_id,
                        &#34;smpp_command&#34;: smpp_command,
                        &#34;send_request&#34;: send_request,
                    }
                )
                if TESTING:
                    # offer escape hatch for tests to come out of endless loop
                    return item_to_dequeue
            else:
                # throttle_handler didn&#39;t allow us to send request.
                self.logger.info(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;send_request&#34;: send_request,
                    }
                )
                try:
                    await asyncio.sleep(await self.throttle_handler.throttle_delay())
                except Exception as e:
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error&#34;,
                            &#34;error&#34;: str(e),
                        }
                    )
                    continue
                if TESTING:
                    # offer escape hatch for tests to come out of endless loop
                    return &#34;throttle_handler_denied_request&#34;
                continue

    async def receive_data(self, TESTING=False):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        retry_count = 0
        while True:
            self.logger.info({&#34;event&#34;: &#34;naz.Client.receive_data&#34;, &#34;stage&#34;: &#34;start&#34;})
            # todo: look at `pause_reading` and `resume_reading` methods
            command_length_header_data = await self.reader.read(4)
            if command_length_header_data == b&#34;&#34;:
                retry_count += 1
                poll_read_interval = self.retry_after(retry_count)
                self.logger.info(
                    {
                        &#34;event&#34;: &#34;naz.Client.receive_data&#34;,
                        &#34;stage&#34;: &#34;start&#34;,
                        &#34;state&#34;: &#34;no data received from SMSC. sleeping for {0}minutes&#34;.format(
                            poll_read_interval / 60
                        ),
                        &#34;retry_count&#34;: retry_count,
                    }
                )
                await asyncio.sleep(poll_read_interval)
                continue
            else:
                # we didn&#39;t fail to read from SMSC
                retry_count = 0

            total_pdu_length = struct.unpack(&#34;&gt;I&#34;, command_length_header_data)[0]

            MSGLEN = total_pdu_length - 4
            chunks = []
            bytes_recd = 0
            while bytes_recd &lt; MSGLEN:
                chunk = await self.reader.read(min(MSGLEN - bytes_recd, 2048))
                if chunk == b&#34;&#34;:
                    err = RuntimeError(&#34;socket connection broken&#34;)
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.receive_data&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;socket connection broken&#34;,
                            &#34;error&#34;: str(err),
                        }
                    )
                    raise err
                chunks.append(chunk)
                bytes_recd = bytes_recd + len(chunk)
            full_pdu_data = command_length_header_data + b&#34;&#34;.join(chunks)
            await self.parse_response_pdu(full_pdu_data)
            self.logger.info({&#34;event&#34;: &#34;naz.Client.receive_data&#34;, &#34;stage&#34;: &#34;end&#34;})
            if TESTING:
                # offer escape hatch for tests to come out of endless loop
                return full_pdu_data

    async def parse_response_pdu(self, pdu):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        self.logger.info({&#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;, &#34;stage&#34;: &#34;start&#34;})

        header_data = pdu[:16]
        command_id_header_data = header_data[4:8]
        command_status_header_data = header_data[8:12]
        sequence_number_header_data = header_data[12:16]

        command_id = struct.unpack(&#34;&gt;I&#34;, command_id_header_data)[0]
        command_status = struct.unpack(&#34;&gt;I&#34;, command_status_header_data)[0]
        sequence_number = struct.unpack(&#34;&gt;I&#34;, sequence_number_header_data)[0]

        # get associated user supplied log_id if any
        try:
            log_id, hook_metadata = await self.correlation_handler.get(
                sequence_number=sequence_number
            )
        except Exception as e:
            log_id, hook_metadata = &#34;&#34;, &#34;&#34;
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater get error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        smpp_command = self.search_by_command_id_code(command_id)
        if not smpp_command:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;command_id:{0} is unknown.&#34;.format(command_id),
                }
            )
            raise ValueError(&#34;command_id:{0} is unknown.&#34;.format(command_id))

        await self.speficic_handlers(
            smpp_command=smpp_command,
            command_status_value=command_status,
            sequence_number=sequence_number,
            log_id=log_id,
            hook_metadata=hook_metadata,
        )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;command_status&#34;: command_status,
            }
        )

    async def speficic_handlers(
        self, smpp_command, command_status_value, sequence_number, log_id, hook_metadata
    ):
        &#34;&#34;&#34;
        this handles parsing speficic
        &#34;&#34;&#34;
        commandStatus = self.search_by_command_status_value(
            command_status_value=command_status_value
        )
        if not commandStatus:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;error&#34;: &#34;command_status:{0} is unknown.&#34;.format(command_status_value),
                }
            )
        elif commandStatus.value != SmppCommandStatus.ESME_ROK.value:
            # we got an error from SMSC
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;command_status&#34;: commandStatus.value,
                    &#34;state&#34;: commandStatus.description,
                }
            )
        else:
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;command_status&#34;: commandStatus.value,
                    &#34;state&#34;: commandStatus.description,
                }
            )

        try:
            # call throttling handler
            if commandStatus.value == SmppCommandStatus.ESME_ROK.value:
                await self.throttle_handler.not_throttled()
            elif commandStatus.value == SmppCommandStatus.ESME_RTHROTTLED.value:
                await self.throttle_handler.throttled()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: commandStatus.description,
                }
            )

        if smpp_command in [
            SmppCommand.BIND_TRANSCEIVER,
            SmppCommand.UNBIND_RESP,
            SmppCommand.SUBMIT_SM,  # We dont expect SMSC to send `submit_sm` to us.
            SmppCommand.DELIVER_SM_RESP,
            # we will never send a deliver_sm request to SMSC, which means we never
            # have to handle deliver_sm_resp
            SmppCommand.ENQUIRE_LINK_RESP,
            SmppCommand.GENERIC_NACK,  # we can ignore this
        ]:
            # we never have to handle this
            pass
        elif smpp_command == SmppCommand.BIND_TRANSCEIVER_RESP:
            # the body of `bind_transceiver_resp` only has `system_id` which is a
            # C-Octet String of variable length upto 16 octets
            if commandStatus.value == SmppCommandStatus.ESME_ROK.value:
                self.current_session_state = SmppSessionState.BOUND_TRX
        elif smpp_command == SmppCommand.UNBIND:
            # we need to handle this since we need to send unbind_resp
            # it has no body
            await self.unbind_resp(sequence_number=sequence_number)
        elif smpp_command == SmppCommand.SUBMIT_SM_RESP:
            # the body of this only has `message_id` which is a C-Octet String of variable length upto 65 octets.
            # This field contains the SMSC message_id of the submitted message.
            # It may be used at a later stage to query the status of a message, cancel
            # or replace the message.
            pass
        elif smpp_command == SmppCommand.DELIVER_SM:
            # HEADER::
            # command_length, int, 4octet
            # command_id, int, 4octet. `deliver_sm`
            # command_status, int, 4octet. Unused, Set to NULL.
            # sequence_number, int, 4octet. The associated `deliver_sm_resp` PDU should echo the same sequence_number.

            # BODY::
            # see section 4.6.1 of smpp v3.4 spec
            # we want to handle this pdu, bcoz we are expected to send back deliver_sm_resp
            # the body of this has the following params
            # service_type, C-Octet String, max 6 octets
            # source_addr_ton, Int, 1 octet, can be NULL
            # source_addr_npi, Int, 1 octet, can be NULL
            # source_addr, C-Octet String, max 21 octet, can be NULL
            # dest_addr_ton, Int, 1 octet
            # dest_addr_npi, Int, 1 octet
            # destination_addr,  C-Octet String, max 21 octet
            # esm_class, Int, 1 octet
            # protocol_id, Int, 1 octet
            # priority_flag, Int, 1 octet
            # schedule_delivery_time, C-Octet String, 1 octet, must be set to NULL.
            # validity_period, C-Octet String, 1 octet, must be set to NULL.
            # registered_delivery, Int, 1 octet
            # replace_if_present_flag, Int, 1 octet, must be set to NULL.
            # data_coding, Int, 1 octet
            # sm_default_msg_id, Int, 1 octet, must be set to NULL.
            # sm_length, Int, 1 octet.It is length of short message user data in octets.
            # short_message, C-Octet String, 0-254 octet

            # NB: user&#39;s hook has already been called.
            await self.deliver_sm_resp(sequence_number=sequence_number)
        elif smpp_command == SmppCommand.ENQUIRE_LINK:
            # we have to handle this. we have to return enquire_link_resp
            # it has no body
            await self.enquire_link_resp(sequence_number=sequence_number)
        else:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;command_status&#34;: commandStatus.code,
                    &#34;state&#34;: commandStatus.description,
                    &#34;error&#34;: &#34;the smpp_command:{0} has not been implemented in naz. please create a github issue&#34;.format(
                        smpp_command
                    ),
                }
            )

        # call user&#39;s hook for responses
        try:
            await self.hook.response(
                smpp_command=smpp_command,
                log_id=log_id,
                hook_metadata=hook_metadata,
                smsc_response=commandStatus,
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;response hook error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

    async def unbind(self):
        &#34;&#34;&#34;
        HEADER::
        # unbind has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `unbind`
        command_status, int, 4octet. Not used. Set to NULL
        sequence_number, int, 4octet.

        `unbind` has no body.

        clients/users should call this method when winding down.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.UNBIND
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        # body
        body = b&#34;&#34;

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = 0x00000000  # not used for `unbind`
        try:
            sequence_number = self.sequence_generator.next_sequence()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        if sequence_number &gt; self.max_sequence_number:
            # prevent third party sequence_generators from ruining our party
            raise ValueError(
                &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                    sequence_number, self.max_sequence_number
                )
            )

        try:
            await self.correlation_handler.put(
                sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater put error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
        full_pdu = header + body
        # dont queue unbind in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
        await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )


class NazLoggingAdapter(logging.LoggerAdapter):
    &#34;&#34;&#34;
    This example adapter expects the passed in dict-like object to have a
    &#39;log_metadata&#39; key, whose value in brackets is apended to the log message.
    &#34;&#34;&#34;

    def process(self, msg, kwargs):
        if isinstance(msg, str):
            return msg, kwargs
        else:
            log_metadata = self.extra.get(&#34;log_metadata&#34;)
            merged_log_event = {**msg, **log_metadata}
            return &#34;{0}&#34;.format(merged_log_event), kwargs


class SmppSessionState:
    &#34;&#34;&#34;
    see section 2.2 of SMPP spec document v3.4
    we are ignoring the other states since we are only concerning ourselves with an ESME in Transceiver mode.
    &#34;&#34;&#34;

    # An ESME has established a network connection to the SMSC but has not yet issued a Bind request.
    OPEN = &#34;OPEN&#34;
    # A connected ESME has requested to bind as an ESME Transceiver (by issuing a bind_transceiver PDU)
    # and has received a response from the SMSC authorising its Bind request.
    BOUND_TRX = &#34;BOUND_TRX&#34;
    # An ESME has unbound from the SMSC and has closed the network connection. The SMSC may also unbind from the ESME.
    CLOSED = &#34;CLOSED&#34;


class SmppCommand:
    &#34;&#34;&#34;
    see section 4 of SMPP spec document v3.4
    &#34;&#34;&#34;

    BIND_TRANSCEIVER = &#34;bind_transceiver&#34;
    BIND_TRANSCEIVER_RESP = &#34;bind_transceiver_resp&#34;
    UNBIND = &#34;unbind&#34;
    UNBIND_RESP = &#34;unbind_resp&#34;
    SUBMIT_SM = &#34;submit_sm&#34;
    SUBMIT_SM_RESP = &#34;submit_sm_resp&#34;
    DELIVER_SM = &#34;deliver_sm&#34;
    DELIVER_SM_RESP = &#34;deliver_sm_resp&#34;
    ENQUIRE_LINK = &#34;enquire_link&#34;
    ENQUIRE_LINK_RESP = &#34;enquire_link_resp&#34;
    GENERIC_NACK = &#34;generic_nack&#34;


class CommandStatus(typing.NamedTuple):
    code: str
    value: int
    description: str


class SmppCommandStatus:
    &#34;&#34;&#34;
    see section 5.1.3 of smpp ver 3.4 spec document
    &#34;&#34;&#34;

    ESME_ROK = CommandStatus(code=&#34;ESME_ROK&#34;, value=0x00000000, description=&#34;Success&#34;)
    ESME_RINVMSGLEN = CommandStatus(
        code=&#34;ESME_RINVMSGLEN&#34;, value=0x00000001, description=&#34;Message Length is invalid&#34;
    )
    ESME_RINVCMDLEN = CommandStatus(
        code=&#34;ESME_RINVCMDLEN&#34;, value=0x00000002, description=&#34;Command Length is invalid&#34;
    )
    ESME_RINVCMDID = CommandStatus(
        code=&#34;ESME_RINVCMDID&#34;, value=0x00000003, description=&#34;Invalid Command ID&#34;
    )
    ESME_RINVBNDSTS = CommandStatus(
        code=&#34;ESME_RINVBNDSTS&#34;,
        value=0x00000004,
        description=&#34;Incorrect BIND Status for given command&#34;,
    )
    ESME_RALYBND = CommandStatus(
        code=&#34;ESME_RALYBND&#34;, value=0x00000005, description=&#34;ESME Already in Bound State&#34;
    )
    ESME_RINVPRTFLG = CommandStatus(
        code=&#34;ESME_RINVPRTFLG&#34;, value=0x00000006, description=&#34;Invalid Priority Flag&#34;
    )
    ESME_RINVREGDLVFLG = CommandStatus(
        code=&#34;ESME_RINVREGDLVFLG&#34;, value=0x00000007, description=&#34;Invalid Registered Delivery Flag&#34;
    )
    ESME_RSYSERR = CommandStatus(code=&#34;ESME_RSYSERR&#34;, value=0x00000008, description=&#34;System Error&#34;)
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000009,description= &#34;Reserved&#34;)
    ESME_RINVSRCADR = CommandStatus(
        code=&#34;ESME_RINVSRCADR&#34;, value=0x0000000A, description=&#34;Invalid Source Address&#34;
    )
    ESME_RINVDSTADR = CommandStatus(
        code=&#34;ESME_RINVDSTADR&#34;, value=0x0000000B, description=&#34;Invalid Dest Addr&#34;
    )
    ESME_RINVMSGID = CommandStatus(
        code=&#34;ESME_RINVMSGID&#34;, value=0x0000000C, description=&#34;Message ID is invalid&#34;
    )
    ESME_RBINDFAIL = CommandStatus(
        code=&#34;ESME_RBINDFAIL&#34;, value=0x0000000D, description=&#34;Bind Failed&#34;
    )
    ESME_RINVPASWD = CommandStatus(
        code=&#34;ESME_RINVPASWD&#34;, value=0x0000000E, description=&#34;Invalid Password&#34;
    )
    ESME_RINVSYSID = CommandStatus(
        code=&#34;ESME_RINVSYSID&#34;, value=0x0000000F, description=&#34;Invalid System ID&#34;
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000010,description= &#34;Reserved&#34;)
    ESME_RCANCELFAIL = CommandStatus(
        code=&#34;ESME_RCANCELFAIL&#34;, value=0x00000011, description=&#34;Cancel SM Failed&#34;
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000012,description= &#34;Reserved&#34;)
    ESME_RREPLACEFAIL = CommandStatus(
        code=&#34;ESME_RREPLACEFAIL&#34;, value=0x00000013, description=&#34;Replace SM Failed&#34;
    )
    ESME_RMSGQFUL = CommandStatus(
        code=&#34;ESME_RMSGQFUL&#34;, value=0x00000014, description=&#34;Message Queue Full&#34;
    )
    ESME_RINVSERTYP = CommandStatus(
        code=&#34;ESME_RINVSERTYP&#34;, value=0x00000015, description=&#34;Invalid Service Type&#34;
    )
    # Reserved 0x00000016 - 0x00000032 Reserved
    ESME_RINVNUMDESTS = CommandStatus(
        code=&#34;ESME_RINVNUMDESTS&#34;, value=0x00000033, description=&#34;Invalid number of destinations&#34;
    )
    ESME_RINVDLNAME = CommandStatus(
        code=&#34;ESME_RINVNUMDESTS&#34;, value=0x00000034, description=&#34;Invalid Distribution List name&#34;
    )
    # Reserved 0x00000035 - 0x0000003F Reserved
    ESME_RINVDESTFLAG = CommandStatus(
        code=&#34;ESME_RINVDESTFLAG&#34;,
        value=0x00000040,
        description=&#34;Destination flag is invalid (submit_multi)&#34;,
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000041,description= &#34;Reserved&#34;)
    ESME_RINVSUBREP = CommandStatus(
        code=&#34;ESME_RINVSUBREP&#34;,
        value=0x00000042,
        description=&#34;Invalid (submit with replace) request(i.e. submit_sm with replace_if_present_flag set)&#34;,
    )
    ESME_RINVESMCLASS = CommandStatus(
        code=&#34;ESME_RINVESMCLASS&#34;, value=0x00000043, description=&#34;Invalid esm_class field data&#34;
    )
    ESME_RCNTSUBDL = CommandStatus(
        code=&#34;ESME_RCNTSUBDL&#34;, value=0x00000044, description=&#34;Cannot Submit to Distribution List&#34;
    )
    ESME_RSUBMITFAIL = CommandStatus(
        code=&#34;ESME_RSUBMITFAIL&#34;, value=0x00000045, description=&#34;Submit_sm or submit_multi failed&#34;
    )
    # Reserved 0x00000046 - 0x00000047 Reserved
    ESME_RINVSRCTON = CommandStatus(
        code=&#34;ESME_RINVSRCTON&#34;, value=0x00000048, description=&#34;Invalid Source address TON&#34;
    )
    ESME_RINVSRCNPI = CommandStatus(
        code=&#34;ESME_RINVSRCNPI&#34;, value=0x00000049, description=&#34;Invalid Source address NPI&#34;
    )
    ESME_RINVDSTTON = CommandStatus(
        code=&#34;ESME_RINVDSTTON&#34;, value=0x00000050, description=&#34;Invalid Destination address TON&#34;
    )
    ESME_RINVDSTNPI = CommandStatus(
        code=&#34;ESME_RINVDSTNPI&#34;, value=0x00000051, description=&#34;Invalid Destination address NPI&#34;
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000052,description= &#34;Reserved&#34;)
    ESME_RINVSYSTYP = CommandStatus(
        code=&#34;ESME_RINVSYSTYP&#34;, value=0x00000053, description=&#34;Invalid system_type field&#34;
    )
    ESME_RINVREPFLAG = CommandStatus(
        code=&#34;ESME_RINVREPFLAG&#34;, value=0x00000054, description=&#34;Invalid replace_if_present flag&#34;
    )
    ESME_RINVNUMMSGS = CommandStatus(
        code=&#34;ESME_RINVNUMMSGS&#34;, value=0x00000055, description=&#34;Invalid number of messages&#34;
    )
    # Reserved 0x00000056 - 0x00000057 Reserved
    ESME_RTHROTTLED = CommandStatus(
        code=&#34;ESME_RTHROTTLED&#34;,
        value=0x00000058,
        description=&#34;Throttling error (ESME has exceeded allowed message limits)&#34;,
    )
    # Reserved 0x00000059 - 0x00000060 Reserved
    ESME_RINVSCHED = CommandStatus(
        code=&#34;ESME_RINVSCHED&#34;, value=0x00000061, description=&#34;Invalid Scheduled Delivery Time&#34;
    )
    ESME_RINVEXPIRY = CommandStatus(
        code=&#34;ESME_RINVEXPIRY&#34;,
        value=0x00000062,
        description=&#34;Invalid message validity period (Expiry time)&#34;,
    )
    ESME_RINVDFTMSGID = CommandStatus(
        code=&#34;ESME_RINVDFTMSGID&#34;,
        value=0x00000063,
        description=&#34;Predefined Message Invalid or Not Found&#34;,
    )
    ESME_RX_T_APPN = CommandStatus(
        code=&#34;ESME_RX_T_APPN&#34;,
        value=0x00000064,
        description=&#34;ESME Receiver Temporary App Error Code&#34;,
    )
    ESME_RX_P_APPN = CommandStatus(
        code=&#34;ESME_RX_P_APPN&#34;,
        value=0x00000065,
        description=&#34;ESME Receiver Permanent App Error Code&#34;,
    )
    ESME_RX_R_APPN = CommandStatus(
        code=&#34;ESME_RX_R_APPN&#34;,
        value=0x00000066,
        description=&#34;ESME Receiver Reject Message Error Code&#34;,
    )
    ESME_RQUERYFAIL = CommandStatus(
        code=&#34;ESME_RQUERYFAIL&#34;, value=0x00000067, description=&#34;query_sm request failed&#34;
    )
    # Reserved 0x00000068 - 0x000000BF Reserved
    ESME_RINVOPTPARSTREAM = CommandStatus(
        code=&#34;ESME_RINVOPTPARSTREAM&#34;,
        value=0x000000C0,
        description=&#34;Error in the optional part of the PDU Body.&#34;,
    )
    ESME_ROPTPARNOTALLWD = CommandStatus(
        code=&#34;ESME_ROPTPARNOTALLWD&#34;, value=0x000000C1, description=&#34;Optional Parameter not allowed&#34;
    )
    ESME_RINVPARLEN = CommandStatus(
        code=&#34;ESME_RINVPARLEN&#34;, value=0x000000C2, description=&#34;Invalid Parameter Length.&#34;
    )
    ESME_RMISSINGOPTPARAM = CommandStatus(
        code=&#34;ESME_RMISSINGOPTPARAM&#34;,
        value=0x000000C3,
        description=&#34;Expected Optional Parameter missing&#34;,
    )
    ESME_RINVOPTPARAMVAL = CommandStatus(
        code=&#34;ESME_RINVOPTPARAMVAL&#34;,
        value=0x000000C4,
        description=&#34;Invalid Optional Parameter Value&#34;,
    )
    # Reserved 0x000000C5 - 0x000000FD Reserved
    ESME_RDELIVERYFAILURE = CommandStatus(
        code=&#34;ESME_RDELIVERYFAILURE&#34;,
        value=0x000000FE,
        description=&#34;Delivery Failure (used for data_sm_resp)&#34;,
    )
    ESME_RUNKNOWNERR = CommandStatus(
        code=&#34;ESME_RUNKNOWNERR&#34;, value=0x000000FF, description=&#34;Unknown Error&#34;
    )
    # Reserved for SMPP extension 0x00000100 - 0x000003FF Reserved for SMPP extension
    # Reserved for SMSC vendor specific errors 0x00000400 - 0x000004FF Reserved for SMSC vendor specific errors
    # Reserved 0x00000500 - 0xFFFFFFFF Reserved


class DataCoding(typing.NamedTuple):
    code: str
    value: int
    description: str


class SmppDataCoding:
    &#34;&#34;&#34;
    see section 5.2.19 of smpp ver 3.4 spec document.
    also see:
      1. https://github.com/praekelt/vumi/blob/767eac623c81cc4b2e6ea9fbd6a3645f121ef0aa/vumi/transports/smpp/processors/default.py#L260
      2. https://docs.python.org/3/library/codecs.html
      3. https://docs.python.org/3/library/codecs.html#standard-encodings

    The attributes of this class are equivalent to some of the names found in the python standard-encodings documentation
    ie; https://docs.python.org/3/library/codecs.html#standard-encodings
    &#34;&#34;&#34;

    gsm0338 = DataCoding(code=&#34;gsm0338&#34;, value=0b00000000, description=&#34;SMSC Default Alphabet&#34;)
    ascii = DataCoding(
        code=&#34;ascii&#34;, value=0b00000001, description=&#34;IA5(CCITT T.50) / ASCII(ANSI X3.4)&#34;
    )
    octet_unspecified_I = DataCoding(
        code=&#34;octet_unspecified_I&#34;,
        value=0b00000010,
        description=&#34;Octet unspecified(8 - bit binary)&#34;,
    )
    latin_1 = DataCoding(code=&#34;latin_1&#34;, value=0b00000011, description=&#34;Latin 1 (ISO - 8859 - 1)&#34;)
    octet_unspecified_II = DataCoding(
        code=&#34;octet_unspecified_II&#34;,
        value=0b00000100,
        description=&#34;Octet unspecified(8 - bit binary)&#34;,
    )
    # iso2022_jp, iso2022jp and iso-2022-jp are aliases
    # see: https://stackoverflow.com/a/43240579/2768067
    iso2022_jp = DataCoding(code=&#34;iso2022_jp&#34;, value=0b00000101, description=&#34;JIS(X 0208 - 1990)&#34;)
    iso8859_5 = DataCoding(
        code=&#34;iso8859_5&#34;, value=0b00000110, description=&#34;Cyrllic(ISO - 8859 - 5)&#34;
    )
    iso8859_8 = DataCoding(
        code=&#34;iso8859_8&#34;, value=0b00000111, description=&#34;Latin / Hebrew(ISO - 8859 - 8)&#34;
    )
    # see: https://stackoverflow.com/a/14488478/2768067
    utf_16_be = DataCoding(
        code=&#34;utf_16_be&#34;, value=0b00001000, description=&#34;UCS2(ISO / IEC - 10646)&#34;
    )
    ucs2 = DataCoding(code=&#34;ucs2&#34;, value=0b00001000, description=&#34;UCS2(ISO / IEC - 10646)&#34;)
    shift_jis = DataCoding(code=&#34;shift_jis&#34;, value=0b00001001, description=&#34;Pictogram Encoding&#34;)
    iso2022jp = DataCoding(
        code=&#34;iso2022jp&#34;, value=0b00001010, description=&#34;ISO - 2022 - JP(Music Codes)&#34;
    )
    # reservedI= DataCoding(code=&#34;reservedI&#34;, value=0b00001011, description= &#34;reserved&#34;)
    # reservedII= DataCoding(code=&#34;reservedII&#34;, value=0b00001100, description= &#34;reserved&#34;)
    euc_kr = DataCoding(code=&#34;euc_kr&#34;, value=0b00001110, description=&#34;KS C 5601&#34;)

    # not the same as iso2022_jp but ... ¯\_(ツ)_/¯
    # iso-2022-jp=DataCoding(code=&#34;iso-2022-jp&#34;, value=0b00001101, description=&#34;Extended Kanji JIS(X 0212 - 1990)&#34;)

    # 00001111 - 10111111 reserved
    # 0b1100xxxx GSM MWI control - see [GSM 03.38]
    # 0b1101xxxx GSM MWI control - see [GSM 03.38]
    # 0b1110xxxx reserved
    # 0b1111xxxx GSM message class control - see [GSM 03.38]}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="naz.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Client:
    &#34;&#34;&#34;
    &#34;&#34;&#34;

    def __init__(
        self,
        async_loop,
        smsc_host,
        smsc_port,
        system_id,
        password,
        outboundqueue,
        client_id=None,
        system_type=&#34;&#34;,
        addr_ton=0,
        addr_npi=0,
        address_range=&#34;&#34;,
        encoding=&#34;gsm0338&#34;,
        interface_version=34,
        service_type=&#34;CMT&#34;,  # section 5.2.11
        source_addr_ton=0x00000001,  # section 5.2.5
        source_addr_npi=0x00000001,
        dest_addr_ton=0x00000001,
        dest_addr_npi=0x00000001,
        # xxxxxx00 store-and-forward
        # xx0010xx Short Message contains ESME Delivery Acknowledgement
        # 00xxxxxx No specific features selected
        esm_class=0b00000011,  # section 5.2.12
        protocol_id=0x00000000,
        priority_flag=0x00000000,
        schedule_delivery_time=&#34;&#34;,
        validity_period=&#34;&#34;,
        # xxxxxx01 SMSC Delivery Receipt requested where final delivery outcome is delivery success or failure
        # xxxx01xx SME Delivery Acknowledgement requested
        # xxx0xxxx No Intermediate notification requested
        # all other values reserved
        registered_delivery=0b00000001,  # see section 5.2.17
        replace_if_present_flag=0x00000000,
        sm_default_msg_id=0x00000000,
        enquire_link_interval=300,
        loglevel=&#34;DEBUG&#34;,
        log_metadata=None,
        codec_class=None,
        codec_errors_level=&#34;strict&#34;,
        rateLimiter=None,
        hook=None,
        sequence_generator=None,
        throttle_handler=None,
        correlation_handler=None,
    ):
        &#34;&#34;&#34;
        todo: add docs
        &#34;&#34;&#34;
        if loglevel.upper() not in [&#34;DEBUG&#34;, &#34;INFO&#34;, &#34;WARNING&#34;, &#34;ERROR&#34;, &#34;CRITICAL&#34;]:
            raise ValueError(
                &#34;&#34;&#34;loglevel should be one of; &#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARNING&#39;, &#39;ERROR&#39; or &#39;CRITICAL&#39;. not {0}&#34;&#34;&#34;.format(
                    loglevel
                )
            )
        elif not isinstance(log_metadata, (type(None), dict)):
            raise ValueError(
                &#34;&#34;&#34;log_metadata should be of type:: None or dict. You entered {0}&#34;&#34;&#34;.format(
                    type(log_metadata)
                )
            )

        # this allows people to pass in their own event loop eg uvloop.
        self.async_loop = async_loop
        self.smsc_host = smsc_host
        self.smsc_port = smsc_port
        self.system_id = system_id
        self.password = password
        self.outboundqueue = outboundqueue
        self.client_id = client_id
        if not self.client_id:
            self.client_id = &#34;&#34;.join(random.choices(string.ascii_uppercase + string.digits, k=17))
        self.system_type = system_type
        self.interface_version = interface_version
        self.addr_ton = addr_ton
        self.addr_npi = addr_npi
        self.address_range = address_range
        self.encoding = encoding

        self.sequence_generator = sequence_generator
        if not self.sequence_generator:
            self.sequence_generator = sequence.SimpleSequenceGenerator()

        self.max_sequence_number = 0x7FFFFFFF
        self.loglevel = loglevel.upper()
        self.log_metadata = log_metadata
        if not self.log_metadata:
            self.log_metadata = {}
        self.log_metadata.update(
            {&#34;smsc_host&#34;: self.smsc_host, &#34;system_id&#34;: system_id, &#34;client_id&#34;: self.client_id}
        )

        self.codec_errors_level = codec_errors_level
        self.codec_class = codec_class
        if not self.codec_class:
            self.codec_class = nazcodec.SimpleNazCodec(errors=self.codec_errors_level)

        self.service_type = service_type
        self.source_addr_ton = source_addr_ton
        self.source_addr_npi = source_addr_npi
        self.dest_addr_ton = dest_addr_ton
        self.dest_addr_npi = dest_addr_npi
        self.esm_class = esm_class
        self.protocol_id = protocol_id
        self.priority_flag = priority_flag
        self.schedule_delivery_time = schedule_delivery_time
        self.validity_period = validity_period
        self.registered_delivery = registered_delivery
        self.replace_if_present_flag = replace_if_present_flag
        self.sm_default_msg_id = sm_default_msg_id
        self.enquire_link_interval = enquire_link_interval

        # see section 5.1.2.1 of smpp ver 3.4 spec document
        self.command_ids = {
            SmppCommand.BIND_TRANSCEIVER: 0x00000009,
            SmppCommand.BIND_TRANSCEIVER_RESP: 0x80000009,
            SmppCommand.UNBIND: 0x00000006,
            SmppCommand.UNBIND_RESP: 0x80000006,
            SmppCommand.SUBMIT_SM: 0x00000004,
            SmppCommand.SUBMIT_SM_RESP: 0x80000004,
            SmppCommand.DELIVER_SM: 0x00000005,
            SmppCommand.DELIVER_SM_RESP: 0x80000005,
            SmppCommand.ENQUIRE_LINK: 0x00000015,
            SmppCommand.ENQUIRE_LINK_RESP: 0x80000015,
            SmppCommand.GENERIC_NACK: 0x80000000,
        }

        self.data_coding = self.find_data_coding(self.encoding)

        self.reader = None
        self.writer = None

        # NB: currently, naz only uses to log levels; INFO and EXCEPTION
        extra_log_data = {&#34;log_metadata&#34;: self.log_metadata}
        self.logger = logging.getLogger(&#34;naz.client&#34;)
        handler = logging.StreamHandler()
        formatter = logging.Formatter(&#34;%(message)s&#34;)
        handler.setFormatter(formatter)
        if not self.logger.handlers:
            self.logger.addHandler(handler)
        self.logger.setLevel(self.loglevel)
        self.logger = NazLoggingAdapter(self.logger, extra_log_data)

        self.rateLimiter = rateLimiter
        if not self.rateLimiter:
            self.rateLimiter = ratelimiter.SimpleRateLimiter(logger=self.logger)

        self.hook = hook
        if not self.hook:
            self.hook = hooks.SimpleHook(logger=self.logger)

        self.throttle_handler = throttle_handler
        if not self.throttle_handler:
            self.throttle_handler = throttle.SimpleThrottleHandler(logger=self.logger)

        # class storing SMPP sequence_number and their corresponding log_id and/or hook_metadata
        # this will be used to track different pdu&#39;s and user generated log_id
        self.correlation_handler = correlation_handler
        if not self.correlation_handler:
            self.correlation_handler = correlater.SimpleCorrelater()

        # the messages that are published to a queue by either naz
        # or user application should be versioned.
        # This version will enable naz to be able to evolve in future;
        # eg a future version of naz could add/remove the number of required items in a message.
        # This is a bit similar to: http://docs.celeryproject.org/en/latest/internals/protocol.html
        self.naz_message_protocol_version = &#34;1&#34;

        self.current_session_state = SmppSessionState.CLOSED

    @staticmethod
    def find_data_coding(encoding):
        for key, val in SmppDataCoding.__dict__.items():
            if not key.startswith(&#34;__&#34;):
                if encoding == val.code:
                    return val.value
        raise ValueError(&#34;That encoding:{0} is not recognised.&#34;.format(encoding))

    def search_by_command_id_code(self, command_id_code):
        for key, val in self.command_ids.items():
            if val == command_id_code:
                return key
        return None

    @staticmethod
    def search_by_command_status_value(command_status_value):
        # TODO: find a cheaper(better) way of doing this
        for key, val in SmppCommandStatus.__dict__.items():
            if not key.startswith(&#34;__&#34;):
                if command_status_value == val.value:
                    return val
        return None

    @staticmethod
    def retry_after(current_retries):
        &#34;&#34;&#34;
        retries will happen in this sequence;
        1min, 2min, 4min, 8min, 16min, 32min, 16min, 16min, 16min ...
        &#34;&#34;&#34;
        # TODO:
        # 1. give users ability to bring their own retry algorithms.
        # 2. add jitter
        if current_retries &lt; 0:
            current_retries = 0
        if current_retries &gt;= 6:
            return 60 * 16  # 16 minutes
        else:
            return 60 * (1 * (2 ** current_retries))

    async def connect(self):
        self.logger.info({&#34;event&#34;: &#34;naz.Client.connect&#34;, &#34;stage&#34;: &#34;start&#34;})
        reader, writer = await asyncio.open_connection(
            self.smsc_host, self.smsc_port, loop=self.async_loop
        )
        self.reader = reader
        self.writer = writer
        self.logger.info({&#34;event&#34;: &#34;naz.Client.connect&#34;, &#34;stage&#34;: &#34;end&#34;})
        self.current_session_state = SmppSessionState.OPEN
        return reader, writer

    async def tranceiver_bind(self):
        smpp_command = SmppCommand.BIND_TRANSCEIVER
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        # body
        body = b&#34;&#34;
        body = (
            body
            + self.codec_class.encode(self.system_id, self.encoding)
            + chr(0).encode()
            + self.codec_class.encode(self.password, self.encoding)
            + chr(0).encode()
            + self.codec_class.encode(self.system_type, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;I&#34;, self.interface_version)
            + struct.pack(&#34;&gt;I&#34;, self.addr_ton)
            + struct.pack(&#34;&gt;I&#34;, self.addr_npi)
            + self.codec_class.encode(self.address_range, self.encoding)
            + chr(0).encode()
        )

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        # the status for success see section 5.1.3
        command_status = SmppCommandStatus.ESME_ROK.value
        try:
            sequence_number = self.sequence_generator.next_sequence()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;smpp_command&#34;: smpp_command,
                }
            )

        if sequence_number &gt; self.max_sequence_number:
            # prevent third party sequence_generators from ruining our party
            raise ValueError(
                &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                    sequence_number, self.max_sequence_number
                )
            )

        # associate sequence_number with log_id.
        # this will enable us to also associate responses and thus enhancing traceability of all workflows
        try:
            await self.correlation_handler.put(
                sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater put error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
        full_pdu = header + body
        await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        return full_pdu

    async def enquire_link(self, TESTING=False):
        &#34;&#34;&#34;
        HEADER::
        # enquire_link has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `enquire_link`
        command_status, int, 4octet. Not used. Set to NULL
        sequence_number, int, 4octet.

        `enquire_link` has no body.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.ENQUIRE_LINK
        while True:
            if self.current_session_state != SmppSessionState.BOUND_TRX:
                # you can only send enquire_link request when session state is BOUND_TRX
                await asyncio.sleep(self.enquire_link_interval)

            log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
            # body
            body = b&#34;&#34;

            # header
            command_length = 16 + len(body)  # 16 is for headers
            command_id = self.command_ids[smpp_command]
            command_status = 0x00000000  # not used for `enquire_link`
            try:
                sequence_number = self.sequence_generator.next_sequence()
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;error&#34;: str(e),
                        &#34;log_id&#34;: log_id,
                        &#34;smpp_command&#34;: smpp_command,
                    }
                )
            if sequence_number &gt; self.max_sequence_number:
                # prevent third party sequence_generators from ruining our party
                raise ValueError(
                    &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                        sequence_number, self.max_sequence_number
                    )
                )

            try:
                await self.correlation_handler.put(
                    sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
                )
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;smpp_command&#34;: smpp_command,
                        &#34;log_id&#34;: log_id,
                        &#34;state&#34;: &#34;correlater put error&#34;,
                        &#34;error&#34;: str(e),
                    }
                )

            header = struct.pack(
                &#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number
            )
            full_pdu = header + body
            # dont queue enquire_link in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
            await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
            if TESTING:
                return full_pdu
            await asyncio.sleep(self.enquire_link_interval)

    async def enquire_link_resp(self, sequence_number):
        &#34;&#34;&#34;
        HEADER::
        # enquire_link_resp has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `enquire_link_resp`
        command_status, int, 4octet. ESME_ROK (Success)
        sequence_number, int, 4octet. Set to the same sequence number of original `enquire_link` PDU

        `enquire_link_resp` has no body.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.ENQUIRE_LINK_RESP
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

        # body
        body = b&#34;&#34;

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = SmppCommandStatus.ESME_ROK.value
        sequence_number = sequence_number
        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

        full_pdu = header + body
        item_to_enqueue = {
            &#34;version&#34;: self.naz_message_protocol_version,
            &#34;log_id&#34;: log_id,
            &#34;pdu&#34;: full_pdu,
            &#34;smpp_command&#34;: smpp_command,
        }
        try:
            await self.outboundqueue.enqueue(item_to_enqueue)
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    async def unbind_resp(self, sequence_number):
        &#34;&#34;&#34;
        HEADER::
        # unbind_resp has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `unbind_resp`
        command_status, int, 4octet. Indicates outcome of original unbind request, eg ESME_ROK (Success)
        sequence_number, int, 4octet. Set to the same sequence number of original `unbind` PDU

        `unbind_resp` has no body.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.UNBIND_RESP
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind_resp&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

        # body
        body = b&#34;&#34;

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = SmppCommandStatus.ESME_ROK.value
        sequence_number = sequence_number
        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

        full_pdu = header + body
        # dont queue unbind_resp in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
        await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    async def deliver_sm_resp(self, sequence_number):
        &#34;&#34;&#34;
        HEADER::
        # deliver_sm_resp has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `deliver_sm_resp`
        command_status, int, 4octet. Indicates outcome of deliver_sm request, eg. ESME_ROK (Success)
        sequence_number, int, 4octet.  Set to the same sequence_number of `deliver_sm` PDU.

        BODY::
        message_id, c-octet String, 1octet. This field is unused and is set to NULL.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.DELIVER_SM_RESP
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        # body
        body = b&#34;&#34;
        message_id = &#34;&#34;
        body = body + self.codec_class.encode(message_id, self.encoding) + chr(0).encode()

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = SmppCommandStatus.ESME_ROK.value
        sequence_number = sequence_number
        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

        full_pdu = header + body
        item_to_enqueue = {
            &#34;version&#34;: self.naz_message_protocol_version,
            &#34;log_id&#34;: log_id,
            &#34;pdu&#34;: full_pdu,
            &#34;smpp_command&#34;: smpp_command,
        }
        try:
            await self.outboundqueue.enqueue(item_to_enqueue)
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )

        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    # this method just enqueues a submit_sm msg to queue
    async def submit_sm(self, short_message, log_id, source_addr, destination_addr):
        &#34;&#34;&#34;
        HEADER::
        # submit_sm has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `submit_sm`
        command_status, int, 4octet. Not used. Set to NULL
        sequence_number, int, 4octet.  The associated submit_sm_resp PDU will echo this sequence number.

        BODY::
        # submit_sm has the following pdu body. NB: They SHOULD be put in the body in the ORDER presented here.
        # service_type, c-octet str, max 6octet. eg NULL, &#34;USSD&#34;, &#34;CMT&#34; etc
        # source_addr_ton, int , 1octet,
        # source_addr_npi, int, 1octet
        # source_addr, c-octet str, max 21octet. eg; This is usually the senders phone Number
        # dest_addr_ton, int, 1octet
        # dest_addr_npi, int, 1octet
        # destination_addr,  C-Octet String, max 21 octet. eg; This is usually the recipients phone Number
        # esm_class, int, 1octet
        # protocol_id, int, 1octet
        # priority_flag, int, 1octet
        # schedule_delivery_time, c-octet str, 1 or 17 octets. NULL for immediate message delivery.
        # validity_period, c-octet str, 1 or 17 octets.  NULL for SMSC default.
        # registered_delivery, int, 1octet
        # replace_if_present_flag, int, 1octet
        # data_coding, int, 1octet. Defines the encoding scheme of the short message user data. Bits 7 6 5 4 3 2 1 0
        # sm_default_msg_id, int, 1octet. SMSC index of a pre-defined(`canned`) message.  If not using an SMSC canned message, set to NULL
        # sm_length, int, 1octet. Length in octets of the `short_message`.
        # short_message, Octet-String(NOT c-octet str), 0-254 octets.
        NB: 1. Applications which need to send messages longer than 254 octets should use the `message_payload` optional parameter.
               In this case the `sm_length` field should be set to zero
               u cant use both `short_message` and `message_payload`
            2. Octet String - A series of octets, not necessarily NULL terminated.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.SUBMIT_SM
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        item_to_enqueue = {
            &#34;version&#34;: self.naz_message_protocol_version,
            &#34;smpp_command&#34;: smpp_command,
            &#34;short_message&#34;: short_message,
            &#34;log_id&#34;: log_id,
            &#34;source_addr&#34;: source_addr,
            &#34;destination_addr&#34;: destination_addr,
        }
        try:
            await self.outboundqueue.enqueue(item_to_enqueue)
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    async def build_submit_sm_pdu(
        self, short_message, log_id, hook_metadata, source_addr, destination_addr
    ):
        smpp_command = SmppCommand.SUBMIT_SM
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        encoded_short_message = self.codec_class.encode(short_message, self.encoding)
        sm_length = len(encoded_short_message)

        # body
        body = b&#34;&#34;
        body = (
            body
            + self.codec_class.encode(self.service_type, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.source_addr_ton)
            + struct.pack(&#34;&gt;B&#34;, self.source_addr_npi)
            + self.codec_class.encode(source_addr, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.dest_addr_ton)
            + struct.pack(&#34;&gt;B&#34;, self.dest_addr_npi)
            + self.codec_class.encode(destination_addr, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.esm_class)
            + struct.pack(&#34;&gt;B&#34;, self.protocol_id)
            + struct.pack(&#34;&gt;B&#34;, self.priority_flag)
            + self.codec_class.encode(self.schedule_delivery_time, self.encoding)
            + chr(0).encode()
            + self.codec_class.encode(self.validity_period, self.encoding)
            + chr(0).encode()
            + struct.pack(&#34;&gt;B&#34;, self.registered_delivery)
            + struct.pack(&#34;&gt;B&#34;, self.replace_if_present_flag)
            + struct.pack(&#34;&gt;B&#34;, self.data_coding)
            + struct.pack(&#34;&gt;B&#34;, self.sm_default_msg_id)
            + struct.pack(&#34;&gt;B&#34;, sm_length)
            + self.codec_class.encode(short_message, self.encoding)
        )

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        # the status for success see section 5.1.3
        command_status = 0x00000000  # not used for `submit_sm`
        try:
            sequence_number = self.sequence_generator.next_sequence()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        if sequence_number &gt; self.max_sequence_number:
            # prevent third party sequence_generators from ruining our party
            raise ValueError(
                &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                    sequence_number, self.max_sequence_number
                )
            )

        try:
            await self.correlation_handler.put(
                sequence_number=sequence_number, log_id=log_id, hook_metadata=hook_metadata
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater put error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
        full_pdu = header + body
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;short_message&#34;: short_message,
                &#34;source_addr&#34;: source_addr,
                &#34;destination_addr&#34;: destination_addr,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        return full_pdu

    async def send_data(self, smpp_command, msg, log_id, hook_metadata=&#34;&#34;):
        &#34;&#34;&#34;
        This method does not block; it buffers the data and arranges for it to be sent out asynchronously.
        see: https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write
        &#34;&#34;&#34;
        # todo: look at `set_write_buffer_limits` and `get_write_buffer_limits` methods
        # print(&#34;get_write_buffer_limits:&#34;, writer.transport.get_write_buffer_limits())

        log_msg = &#34;&#34;
        try:
            log_msg = self.codec_class.decode(msg, self.encoding)
            # do not log password, redact it from logs.
            if self.password in log_msg:
                log_msg = log_msg.replace(self.password, &#34;{REDACTED}&#34;)
        except Exception:
            pass
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;msg&#34;: log_msg,
            }
        )

        # check session state to see if we can send messages.
        # see section 2.3 of SMPP spec document v3.4
        if self.current_session_state == SmppSessionState.CLOSED:
            error_msg = &#34;smpp_command: {0} cannot be sent to SMSC when the client session state is: {1}&#34;.format(
                smpp_command, self.current_session_state
            )
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;msg&#34;: log_msg,
                    &#34;current_session_state&#34;: self.current_session_state,
                    &#34;error&#34;: error_msg,
                }
            )
            raise ValueError(error_msg)
        elif self.current_session_state == SmppSessionState.OPEN and smpp_command not in [
            &#34;bind_transmitter&#34;,
            &#34;bind_receiver&#34;,
            &#34;bind_transceiver&#34;,
        ]:
            # only the smpp_command&#39;s listed above are allowed by SMPP spec to be sent
            # if current_session_state == SmppSessionState.OPEN
            error_msg = &#34;smpp_command: {0} cannot be sent to SMSC when the client session state is: {1}&#34;.format(
                smpp_command, self.current_session_state
            )
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;msg&#34;: log_msg,
                    &#34;current_session_state&#34;: self.current_session_state,
                    &#34;error&#34;: error_msg,
                }
            )
            raise ValueError(error_msg)

        if isinstance(msg, str):
            msg = self.codec_class.encode(msg, self.encoding)

        # call user&#39;s hook for requests
        try:
            await self.hook.request(
                smpp_command=smpp_command, log_id=log_id, hook_metadata=hook_metadata
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;request hook error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        # We use writer.drain() which is a flow control method that interacts with the IO write buffer.
        # When the size of the buffer reaches the high watermark,
        # drain blocks until the size of the buffer is drained down to the low watermark and writing can be resumed.
        # When there is nothing to wait for, the drain() returns immediately.
        # ref: https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.drain
        self.writer.write(msg)
        await self.writer.drain()
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;msg&#34;: log_msg,
            }
        )

    async def send_forever(self, TESTING=False):
        retry_count = 0
        while True:
            self.logger.info({&#34;event&#34;: &#34;naz.Client.send_forever&#34;, &#34;stage&#34;: &#34;start&#34;})

            # TODO: there are so many try-except classes in this func.
            # do something about that.
            try:
                # check with throttle handler
                send_request = await self.throttle_handler.allow_request()
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;state&#34;: &#34;send_forever error&#34;,
                        &#34;error&#34;: str(e),
                    }
                )
                continue
            if send_request:
                try:
                    # rate limit ourselves
                    await self.rateLimiter.limit()
                except Exception as e:
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error&#34;,
                            &#34;error&#34;: str(e),
                        }
                    )
                    continue

                try:
                    item_to_dequeue = await self.outboundqueue.dequeue()
                except Exception as e:
                    retry_count += 1
                    poll_queue_interval = self.retry_after(retry_count)
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error. sleeping for {0}minutes&#34;.format(
                                poll_queue_interval / 60
                            ),
                            &#34;retry_count&#34;: retry_count,
                            &#34;error&#34;: str(e),
                        }
                    )
                    await asyncio.sleep(poll_queue_interval)
                    continue
                # we didn&#39;t fail to dequeue a message
                retry_count = 0
                try:
                    log_id = item_to_dequeue[&#34;log_id&#34;]
                    item_to_dequeue[&#34;version&#34;]  # version is a required field
                    smpp_command = item_to_dequeue[&#34;smpp_command&#34;]
                    hook_metadata = item_to_dequeue.get(&#34;hook_metadata&#34;, &#34;&#34;)
                    if smpp_command == SmppCommand.SUBMIT_SM:
                        short_message = item_to_dequeue[&#34;short_message&#34;]
                        source_addr = item_to_dequeue[&#34;source_addr&#34;]
                        destination_addr = item_to_dequeue[&#34;destination_addr&#34;]
                        full_pdu = await self.build_submit_sm_pdu(
                            short_message, log_id, hook_metadata, source_addr, destination_addr
                        )
                    else:
                        full_pdu = item_to_dequeue[&#34;pdu&#34;]
                except KeyError as e:
                    e = KeyError(
                        &#34;enqueued message/object is missing required field:{}&#34;.format(str(e))
                    )
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error&#34;,
                            &#34;error&#34;: str(e),
                        }
                    )
                    continue

                await self.send_data(
                    smpp_command=smpp_command,
                    msg=full_pdu,
                    log_id=log_id,
                    hook_metadata=hook_metadata,
                )
                self.logger.info(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;log_id&#34;: log_id,
                        &#34;smpp_command&#34;: smpp_command,
                        &#34;send_request&#34;: send_request,
                    }
                )
                if TESTING:
                    # offer escape hatch for tests to come out of endless loop
                    return item_to_dequeue
            else:
                # throttle_handler didn&#39;t allow us to send request.
                self.logger.info(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;send_request&#34;: send_request,
                    }
                )
                try:
                    await asyncio.sleep(await self.throttle_handler.throttle_delay())
                except Exception as e:
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;send_forever error&#34;,
                            &#34;error&#34;: str(e),
                        }
                    )
                    continue
                if TESTING:
                    # offer escape hatch for tests to come out of endless loop
                    return &#34;throttle_handler_denied_request&#34;
                continue

    async def receive_data(self, TESTING=False):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        retry_count = 0
        while True:
            self.logger.info({&#34;event&#34;: &#34;naz.Client.receive_data&#34;, &#34;stage&#34;: &#34;start&#34;})
            # todo: look at `pause_reading` and `resume_reading` methods
            command_length_header_data = await self.reader.read(4)
            if command_length_header_data == b&#34;&#34;:
                retry_count += 1
                poll_read_interval = self.retry_after(retry_count)
                self.logger.info(
                    {
                        &#34;event&#34;: &#34;naz.Client.receive_data&#34;,
                        &#34;stage&#34;: &#34;start&#34;,
                        &#34;state&#34;: &#34;no data received from SMSC. sleeping for {0}minutes&#34;.format(
                            poll_read_interval / 60
                        ),
                        &#34;retry_count&#34;: retry_count,
                    }
                )
                await asyncio.sleep(poll_read_interval)
                continue
            else:
                # we didn&#39;t fail to read from SMSC
                retry_count = 0

            total_pdu_length = struct.unpack(&#34;&gt;I&#34;, command_length_header_data)[0]

            MSGLEN = total_pdu_length - 4
            chunks = []
            bytes_recd = 0
            while bytes_recd &lt; MSGLEN:
                chunk = await self.reader.read(min(MSGLEN - bytes_recd, 2048))
                if chunk == b&#34;&#34;:
                    err = RuntimeError(&#34;socket connection broken&#34;)
                    self.logger.exception(
                        {
                            &#34;event&#34;: &#34;naz.Client.receive_data&#34;,
                            &#34;stage&#34;: &#34;end&#34;,
                            &#34;state&#34;: &#34;socket connection broken&#34;,
                            &#34;error&#34;: str(err),
                        }
                    )
                    raise err
                chunks.append(chunk)
                bytes_recd = bytes_recd + len(chunk)
            full_pdu_data = command_length_header_data + b&#34;&#34;.join(chunks)
            await self.parse_response_pdu(full_pdu_data)
            self.logger.info({&#34;event&#34;: &#34;naz.Client.receive_data&#34;, &#34;stage&#34;: &#34;end&#34;})
            if TESTING:
                # offer escape hatch for tests to come out of endless loop
                return full_pdu_data

    async def parse_response_pdu(self, pdu):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        self.logger.info({&#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;, &#34;stage&#34;: &#34;start&#34;})

        header_data = pdu[:16]
        command_id_header_data = header_data[4:8]
        command_status_header_data = header_data[8:12]
        sequence_number_header_data = header_data[12:16]

        command_id = struct.unpack(&#34;&gt;I&#34;, command_id_header_data)[0]
        command_status = struct.unpack(&#34;&gt;I&#34;, command_status_header_data)[0]
        sequence_number = struct.unpack(&#34;&gt;I&#34;, sequence_number_header_data)[0]

        # get associated user supplied log_id if any
        try:
            log_id, hook_metadata = await self.correlation_handler.get(
                sequence_number=sequence_number
            )
        except Exception as e:
            log_id, hook_metadata = &#34;&#34;, &#34;&#34;
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater get error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        smpp_command = self.search_by_command_id_code(command_id)
        if not smpp_command:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;command_id:{0} is unknown.&#34;.format(command_id),
                }
            )
            raise ValueError(&#34;command_id:{0} is unknown.&#34;.format(command_id))

        await self.speficic_handlers(
            smpp_command=smpp_command,
            command_status_value=command_status,
            sequence_number=sequence_number,
            log_id=log_id,
            hook_metadata=hook_metadata,
        )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;command_status&#34;: command_status,
            }
        )

    async def speficic_handlers(
        self, smpp_command, command_status_value, sequence_number, log_id, hook_metadata
    ):
        &#34;&#34;&#34;
        this handles parsing speficic
        &#34;&#34;&#34;
        commandStatus = self.search_by_command_status_value(
            command_status_value=command_status_value
        )
        if not commandStatus:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;error&#34;: &#34;command_status:{0} is unknown.&#34;.format(command_status_value),
                }
            )
        elif commandStatus.value != SmppCommandStatus.ESME_ROK.value:
            # we got an error from SMSC
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;command_status&#34;: commandStatus.value,
                    &#34;state&#34;: commandStatus.description,
                }
            )
        else:
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;command_status&#34;: commandStatus.value,
                    &#34;state&#34;: commandStatus.description,
                }
            )

        try:
            # call throttling handler
            if commandStatus.value == SmppCommandStatus.ESME_ROK.value:
                await self.throttle_handler.not_throttled()
            elif commandStatus.value == SmppCommandStatus.ESME_RTHROTTLED.value:
                await self.throttle_handler.throttled()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: commandStatus.description,
                }
            )

        if smpp_command in [
            SmppCommand.BIND_TRANSCEIVER,
            SmppCommand.UNBIND_RESP,
            SmppCommand.SUBMIT_SM,  # We dont expect SMSC to send `submit_sm` to us.
            SmppCommand.DELIVER_SM_RESP,
            # we will never send a deliver_sm request to SMSC, which means we never
            # have to handle deliver_sm_resp
            SmppCommand.ENQUIRE_LINK_RESP,
            SmppCommand.GENERIC_NACK,  # we can ignore this
        ]:
            # we never have to handle this
            pass
        elif smpp_command == SmppCommand.BIND_TRANSCEIVER_RESP:
            # the body of `bind_transceiver_resp` only has `system_id` which is a
            # C-Octet String of variable length upto 16 octets
            if commandStatus.value == SmppCommandStatus.ESME_ROK.value:
                self.current_session_state = SmppSessionState.BOUND_TRX
        elif smpp_command == SmppCommand.UNBIND:
            # we need to handle this since we need to send unbind_resp
            # it has no body
            await self.unbind_resp(sequence_number=sequence_number)
        elif smpp_command == SmppCommand.SUBMIT_SM_RESP:
            # the body of this only has `message_id` which is a C-Octet String of variable length upto 65 octets.
            # This field contains the SMSC message_id of the submitted message.
            # It may be used at a later stage to query the status of a message, cancel
            # or replace the message.
            pass
        elif smpp_command == SmppCommand.DELIVER_SM:
            # HEADER::
            # command_length, int, 4octet
            # command_id, int, 4octet. `deliver_sm`
            # command_status, int, 4octet. Unused, Set to NULL.
            # sequence_number, int, 4octet. The associated `deliver_sm_resp` PDU should echo the same sequence_number.

            # BODY::
            # see section 4.6.1 of smpp v3.4 spec
            # we want to handle this pdu, bcoz we are expected to send back deliver_sm_resp
            # the body of this has the following params
            # service_type, C-Octet String, max 6 octets
            # source_addr_ton, Int, 1 octet, can be NULL
            # source_addr_npi, Int, 1 octet, can be NULL
            # source_addr, C-Octet String, max 21 octet, can be NULL
            # dest_addr_ton, Int, 1 octet
            # dest_addr_npi, Int, 1 octet
            # destination_addr,  C-Octet String, max 21 octet
            # esm_class, Int, 1 octet
            # protocol_id, Int, 1 octet
            # priority_flag, Int, 1 octet
            # schedule_delivery_time, C-Octet String, 1 octet, must be set to NULL.
            # validity_period, C-Octet String, 1 octet, must be set to NULL.
            # registered_delivery, Int, 1 octet
            # replace_if_present_flag, Int, 1 octet, must be set to NULL.
            # data_coding, Int, 1 octet
            # sm_default_msg_id, Int, 1 octet, must be set to NULL.
            # sm_length, Int, 1 octet.It is length of short message user data in octets.
            # short_message, C-Octet String, 0-254 octet

            # NB: user&#39;s hook has already been called.
            await self.deliver_sm_resp(sequence_number=sequence_number)
        elif smpp_command == SmppCommand.ENQUIRE_LINK:
            # we have to handle this. we have to return enquire_link_resp
            # it has no body
            await self.enquire_link_resp(sequence_number=sequence_number)
        else:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;command_status&#34;: commandStatus.code,
                    &#34;state&#34;: commandStatus.description,
                    &#34;error&#34;: &#34;the smpp_command:{0} has not been implemented in naz. please create a github issue&#34;.format(
                        smpp_command
                    ),
                }
            )

        # call user&#39;s hook for responses
        try:
            await self.hook.response(
                smpp_command=smpp_command,
                log_id=log_id,
                hook_metadata=hook_metadata,
                smsc_response=commandStatus,
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;response hook error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

    async def unbind(self):
        &#34;&#34;&#34;
        HEADER::
        # unbind has the following pdu header:
        command_length, int, 4octet
        command_id, int, 4octet. `unbind`
        command_status, int, 4octet. Not used. Set to NULL
        sequence_number, int, 4octet.

        `unbind` has no body.

        clients/users should call this method when winding down.
        &#34;&#34;&#34;
        smpp_command = SmppCommand.UNBIND
        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        # body
        body = b&#34;&#34;

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = 0x00000000  # not used for `unbind`
        try:
            sequence_number = self.sequence_generator.next_sequence()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        if sequence_number &gt; self.max_sequence_number:
            # prevent third party sequence_generators from ruining our party
            raise ValueError(
                &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                    sequence_number, self.max_sequence_number
                )
            )

        try:
            await self.correlation_handler.put(
                sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater put error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
        full_pdu = header + body
        # dont queue unbind in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
        await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )}</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="naz.client.Client.find_data_coding"><code class="name flex">
<span>def <span class="ident">find_data_coding</span></span>(<span>encoding)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def find_data_coding(encoding):
    for key, val in SmppDataCoding.__dict__.items():
        if not key.startswith(&#34;__&#34;):
            if encoding == val.code:
                return val.value
    raise ValueError(&#34;That encoding:{0} is not recognised.&#34;.format(encoding))}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.retry_after"><code class="name flex">
<span>def <span class="ident">retry_after</span></span>(<span>current_retries)</span>
</code></dt>
<dd>
<section class="desc"><p>retries will happen in this sequence;
1min, 2min, 4min, 8min, 16min, 32min, 16min, 16min, 16min &hellip;</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def retry_after(current_retries):
    &#34;&#34;&#34;
    retries will happen in this sequence;
    1min, 2min, 4min, 8min, 16min, 32min, 16min, 16min, 16min ...
    &#34;&#34;&#34;
    # TODO:
    # 1. give users ability to bring their own retry algorithms.
    # 2. add jitter
    if current_retries &lt; 0:
        current_retries = 0
    if current_retries &gt;= 6:
        return 60 * 16  # 16 minutes
    else:
        return 60 * (1 * (2 ** current_retries))}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.search_by_command_status_value"><code class="name flex">
<span>def <span class="ident">search_by_command_status_value</span></span>(<span>command_status_value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def search_by_command_status_value(command_status_value):
    # TODO: find a cheaper(better) way of doing this
    for key, val in SmppCommandStatus.__dict__.items():
        if not key.startswith(&#34;__&#34;):
            if command_status_value == val.value:
                return val
    return None}</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="naz.client.Client.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, async_loop, smsc_host, smsc_port, system_id, password, outboundqueue, client_id=None, system_type=&#39;&#39;, addr_ton=0, addr_npi=0, address_range=&#39;&#39;, encoding=&#39;gsm0338&#39;, interface_version=34, service_type=&#39;CMT&#39;, source_addr_ton=1, source_addr_npi=1, dest_addr_ton=1, dest_addr_npi=1, esm_class=3, protocol_id=0, priority_flag=0, schedule_delivery_time=&#39;&#39;, validity_period=&#39;&#39;, registered_delivery=1, replace_if_present_flag=0, sm_default_msg_id=0, enquire_link_interval=300, loglevel=&#39;DEBUG&#39;, log_metadata=None, codec_class=None, codec_errors_level=&#39;strict&#39;, rateLimiter=None, hook=None, sequence_generator=None, throttle_handler=None, correlation_handler=None)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>todo</code></strong> :&ensp;<code>add</code> <code>docs</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(
    self,
    async_loop,
    smsc_host,
    smsc_port,
    system_id,
    password,
    outboundqueue,
    client_id=None,
    system_type=&#34;&#34;,
    addr_ton=0,
    addr_npi=0,
    address_range=&#34;&#34;,
    encoding=&#34;gsm0338&#34;,
    interface_version=34,
    service_type=&#34;CMT&#34;,  # section 5.2.11
    source_addr_ton=0x00000001,  # section 5.2.5
    source_addr_npi=0x00000001,
    dest_addr_ton=0x00000001,
    dest_addr_npi=0x00000001,
    # xxxxxx00 store-and-forward
    # xx0010xx Short Message contains ESME Delivery Acknowledgement
    # 00xxxxxx No specific features selected
    esm_class=0b00000011,  # section 5.2.12
    protocol_id=0x00000000,
    priority_flag=0x00000000,
    schedule_delivery_time=&#34;&#34;,
    validity_period=&#34;&#34;,
    # xxxxxx01 SMSC Delivery Receipt requested where final delivery outcome is delivery success or failure
    # xxxx01xx SME Delivery Acknowledgement requested
    # xxx0xxxx No Intermediate notification requested
    # all other values reserved
    registered_delivery=0b00000001,  # see section 5.2.17
    replace_if_present_flag=0x00000000,
    sm_default_msg_id=0x00000000,
    enquire_link_interval=300,
    loglevel=&#34;DEBUG&#34;,
    log_metadata=None,
    codec_class=None,
    codec_errors_level=&#34;strict&#34;,
    rateLimiter=None,
    hook=None,
    sequence_generator=None,
    throttle_handler=None,
    correlation_handler=None,
):
    &#34;&#34;&#34;
    todo: add docs
    &#34;&#34;&#34;
    if loglevel.upper() not in [&#34;DEBUG&#34;, &#34;INFO&#34;, &#34;WARNING&#34;, &#34;ERROR&#34;, &#34;CRITICAL&#34;]:
        raise ValueError(
            &#34;&#34;&#34;loglevel should be one of; &#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARNING&#39;, &#39;ERROR&#39; or &#39;CRITICAL&#39;. not {0}&#34;&#34;&#34;.format(
                loglevel
            )
        )
    elif not isinstance(log_metadata, (type(None), dict)):
        raise ValueError(
            &#34;&#34;&#34;log_metadata should be of type:: None or dict. You entered {0}&#34;&#34;&#34;.format(
                type(log_metadata)
            )
        )

    # this allows people to pass in their own event loop eg uvloop.
    self.async_loop = async_loop
    self.smsc_host = smsc_host
    self.smsc_port = smsc_port
    self.system_id = system_id
    self.password = password
    self.outboundqueue = outboundqueue
    self.client_id = client_id
    if not self.client_id:
        self.client_id = &#34;&#34;.join(random.choices(string.ascii_uppercase + string.digits, k=17))
    self.system_type = system_type
    self.interface_version = interface_version
    self.addr_ton = addr_ton
    self.addr_npi = addr_npi
    self.address_range = address_range
    self.encoding = encoding

    self.sequence_generator = sequence_generator
    if not self.sequence_generator:
        self.sequence_generator = sequence.SimpleSequenceGenerator()

    self.max_sequence_number = 0x7FFFFFFF
    self.loglevel = loglevel.upper()
    self.log_metadata = log_metadata
    if not self.log_metadata:
        self.log_metadata = {}
    self.log_metadata.update(
        {&#34;smsc_host&#34;: self.smsc_host, &#34;system_id&#34;: system_id, &#34;client_id&#34;: self.client_id}
    )

    self.codec_errors_level = codec_errors_level
    self.codec_class = codec_class
    if not self.codec_class:
        self.codec_class = nazcodec.SimpleNazCodec(errors=self.codec_errors_level)

    self.service_type = service_type
    self.source_addr_ton = source_addr_ton
    self.source_addr_npi = source_addr_npi
    self.dest_addr_ton = dest_addr_ton
    self.dest_addr_npi = dest_addr_npi
    self.esm_class = esm_class
    self.protocol_id = protocol_id
    self.priority_flag = priority_flag
    self.schedule_delivery_time = schedule_delivery_time
    self.validity_period = validity_period
    self.registered_delivery = registered_delivery
    self.replace_if_present_flag = replace_if_present_flag
    self.sm_default_msg_id = sm_default_msg_id
    self.enquire_link_interval = enquire_link_interval

    # see section 5.1.2.1 of smpp ver 3.4 spec document
    self.command_ids = {
        SmppCommand.BIND_TRANSCEIVER: 0x00000009,
        SmppCommand.BIND_TRANSCEIVER_RESP: 0x80000009,
        SmppCommand.UNBIND: 0x00000006,
        SmppCommand.UNBIND_RESP: 0x80000006,
        SmppCommand.SUBMIT_SM: 0x00000004,
        SmppCommand.SUBMIT_SM_RESP: 0x80000004,
        SmppCommand.DELIVER_SM: 0x00000005,
        SmppCommand.DELIVER_SM_RESP: 0x80000005,
        SmppCommand.ENQUIRE_LINK: 0x00000015,
        SmppCommand.ENQUIRE_LINK_RESP: 0x80000015,
        SmppCommand.GENERIC_NACK: 0x80000000,
    }

    self.data_coding = self.find_data_coding(self.encoding)

    self.reader = None
    self.writer = None

    # NB: currently, naz only uses to log levels; INFO and EXCEPTION
    extra_log_data = {&#34;log_metadata&#34;: self.log_metadata}
    self.logger = logging.getLogger(&#34;naz.client&#34;)
    handler = logging.StreamHandler()
    formatter = logging.Formatter(&#34;%(message)s&#34;)
    handler.setFormatter(formatter)
    if not self.logger.handlers:
        self.logger.addHandler(handler)
    self.logger.setLevel(self.loglevel)
    self.logger = NazLoggingAdapter(self.logger, extra_log_data)

    self.rateLimiter = rateLimiter
    if not self.rateLimiter:
        self.rateLimiter = ratelimiter.SimpleRateLimiter(logger=self.logger)

    self.hook = hook
    if not self.hook:
        self.hook = hooks.SimpleHook(logger=self.logger)

    self.throttle_handler = throttle_handler
    if not self.throttle_handler:
        self.throttle_handler = throttle.SimpleThrottleHandler(logger=self.logger)

    # class storing SMPP sequence_number and their corresponding log_id and/or hook_metadata
    # this will be used to track different pdu&#39;s and user generated log_id
    self.correlation_handler = correlation_handler
    if not self.correlation_handler:
        self.correlation_handler = correlater.SimpleCorrelater()

    # the messages that are published to a queue by either naz
    # or user application should be versioned.
    # This version will enable naz to be able to evolve in future;
    # eg a future version of naz could add/remove the number of required items in a message.
    # This is a bit similar to: http://docs.celeryproject.org/en/latest/internals/protocol.html
    self.naz_message_protocol_version = &#34;1&#34;

    self.current_session_state = SmppSessionState.CLOSED}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.build_submit_sm_pdu"><code class="name flex">
<span>async def <span class="ident">build_submit_sm_pdu</span></span>(<span>self, short_message, log_id, hook_metadata, source_addr, destination_addr)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def build_submit_sm_pdu(
    self, short_message, log_id, hook_metadata, source_addr, destination_addr
):
    smpp_command = SmppCommand.SUBMIT_SM
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;log_id&#34;: log_id,
            &#34;short_message&#34;: short_message,
            &#34;source_addr&#34;: source_addr,
            &#34;destination_addr&#34;: destination_addr,
            &#34;smpp_command&#34;: smpp_command,
        }
    )
    encoded_short_message = self.codec_class.encode(short_message, self.encoding)
    sm_length = len(encoded_short_message)

    # body
    body = b&#34;&#34;
    body = (
        body
        + self.codec_class.encode(self.service_type, self.encoding)
        + chr(0).encode()
        + struct.pack(&#34;&gt;B&#34;, self.source_addr_ton)
        + struct.pack(&#34;&gt;B&#34;, self.source_addr_npi)
        + self.codec_class.encode(source_addr, self.encoding)
        + chr(0).encode()
        + struct.pack(&#34;&gt;B&#34;, self.dest_addr_ton)
        + struct.pack(&#34;&gt;B&#34;, self.dest_addr_npi)
        + self.codec_class.encode(destination_addr, self.encoding)
        + chr(0).encode()
        + struct.pack(&#34;&gt;B&#34;, self.esm_class)
        + struct.pack(&#34;&gt;B&#34;, self.protocol_id)
        + struct.pack(&#34;&gt;B&#34;, self.priority_flag)
        + self.codec_class.encode(self.schedule_delivery_time, self.encoding)
        + chr(0).encode()
        + self.codec_class.encode(self.validity_period, self.encoding)
        + chr(0).encode()
        + struct.pack(&#34;&gt;B&#34;, self.registered_delivery)
        + struct.pack(&#34;&gt;B&#34;, self.replace_if_present_flag)
        + struct.pack(&#34;&gt;B&#34;, self.data_coding)
        + struct.pack(&#34;&gt;B&#34;, self.sm_default_msg_id)
        + struct.pack(&#34;&gt;B&#34;, sm_length)
        + self.codec_class.encode(short_message, self.encoding)
    )

    # header
    command_length = 16 + len(body)  # 16 is for headers
    command_id = self.command_ids[smpp_command]
    # the status for success see section 5.1.3
    command_status = 0x00000000  # not used for `submit_sm`
    try:
        sequence_number = self.sequence_generator.next_sequence()
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;error&#34;: str(e),
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
    if sequence_number &gt; self.max_sequence_number:
        # prevent third party sequence_generators from ruining our party
        raise ValueError(
            &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                sequence_number, self.max_sequence_number
            )
        )

    try:
        await self.correlation_handler.put(
            sequence_number=sequence_number, log_id=log_id, hook_metadata=hook_metadata
        )
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: &#34;correlater put error&#34;,
                &#34;error&#34;: str(e),
            }
        )

    header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
    full_pdu = header + body
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.build_submit_sm_pdu&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;log_id&#34;: log_id,
            &#34;short_message&#34;: short_message,
            &#34;source_addr&#34;: source_addr,
            &#34;destination_addr&#34;: destination_addr,
            &#34;smpp_command&#34;: smpp_command,
        }
    )
    return full_pdu}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def connect(self):
    self.logger.info({&#34;event&#34;: &#34;naz.Client.connect&#34;, &#34;stage&#34;: &#34;start&#34;})
    reader, writer = await asyncio.open_connection(
        self.smsc_host, self.smsc_port, loop=self.async_loop
    )
    self.reader = reader
    self.writer = writer
    self.logger.info({&#34;event&#34;: &#34;naz.Client.connect&#34;, &#34;stage&#34;: &#34;end&#34;})
    self.current_session_state = SmppSessionState.OPEN
    return reader, writer}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.deliver_sm_resp"><code class="name flex">
<span>async def <span class="ident">deliver_sm_resp</span></span>(<span>self, sequence_number)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>HEADER</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<h1 id="deliver_sm_resp-has-the-following-pdu-header">deliver_sm_resp has the following pdu header:</h1>
<p>command_length, int, 4octet
command_id, int, 4octet. <code>deliver_sm_resp</code>
command_status, int, 4octet. Indicates outcome of deliver_sm request, eg. ESME_ROK (Success)
sequence_number, int, 4octet.
Set to the same sequence_number of <code>deliver_sm</code> PDU.</p>
<dl>
<dt><strong><code>BODY</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<p>message_id, c-octet String, 1octet. This field is unused and is set to NULL.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def deliver_sm_resp(self, sequence_number):
    &#34;&#34;&#34;
    HEADER::
    # deliver_sm_resp has the following pdu header:
    command_length, int, 4octet
    command_id, int, 4octet. `deliver_sm_resp`
    command_status, int, 4octet. Indicates outcome of deliver_sm request, eg. ESME_ROK (Success)
    sequence_number, int, 4octet.  Set to the same sequence_number of `deliver_sm` PDU.

    BODY::
    message_id, c-octet String, 1octet. This field is unused and is set to NULL.
    &#34;&#34;&#34;
    smpp_command = SmppCommand.DELIVER_SM_RESP
    log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )
    # body
    body = b&#34;&#34;
    message_id = &#34;&#34;
    body = body + self.codec_class.encode(message_id, self.encoding) + chr(0).encode()

    # header
    command_length = 16 + len(body)  # 16 is for headers
    command_id = self.command_ids[smpp_command]
    command_status = SmppCommandStatus.ESME_ROK.value
    sequence_number = sequence_number
    header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

    full_pdu = header + body
    item_to_enqueue = {
        &#34;version&#34;: self.naz_message_protocol_version,
        &#34;log_id&#34;: log_id,
        &#34;pdu&#34;: full_pdu,
        &#34;smpp_command&#34;: smpp_command,
    }
    try:
        await self.outboundqueue.enqueue(item_to_enqueue)
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;error&#34;: str(e),
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.deliver_sm_resp&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.enquire_link"><code class="name flex">
<span>async def <span class="ident">enquire_link</span></span>(<span>self, TESTING=False)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>HEADER</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<h1 id="enquire_link-has-the-following-pdu-header">enquire_link has the following pdu header:</h1>
<p>command_length, int, 4octet
command_id, int, 4octet. <code>enquire_link</code>
command_status, int, 4octet. Not used. Set to NULL
sequence_number, int, 4octet.</p>
<p><code>enquire_link</code> has no body.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def enquire_link(self, TESTING=False):
    &#34;&#34;&#34;
    HEADER::
    # enquire_link has the following pdu header:
    command_length, int, 4octet
    command_id, int, 4octet. `enquire_link`
    command_status, int, 4octet. Not used. Set to NULL
    sequence_number, int, 4octet.

    `enquire_link` has no body.
    &#34;&#34;&#34;
    smpp_command = SmppCommand.ENQUIRE_LINK
    while True:
        if self.current_session_state != SmppSessionState.BOUND_TRX:
            # you can only send enquire_link request when session state is BOUND_TRX
            await asyncio.sleep(self.enquire_link_interval)

        log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        # body
        body = b&#34;&#34;

        # header
        command_length = 16 + len(body)  # 16 is for headers
        command_id = self.command_ids[smpp_command]
        command_status = 0x00000000  # not used for `enquire_link`
        try:
            sequence_number = self.sequence_generator.next_sequence()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;error&#34;: str(e),
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                }
            )
        if sequence_number &gt; self.max_sequence_number:
            # prevent third party sequence_generators from ruining our party
            raise ValueError(
                &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                    sequence_number, self.max_sequence_number
                )
            )

        try:
            await self.correlation_handler.put(
                sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
            )
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;log_id&#34;: log_id,
                    &#34;state&#34;: &#34;correlater put error&#34;,
                    &#34;error&#34;: str(e),
                }
            )

        header = struct.pack(
            &#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number
        )
        full_pdu = header + body
        # dont queue enquire_link in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
        await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.enquire_link&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
        if TESTING:
            return full_pdu
        await asyncio.sleep(self.enquire_link_interval)}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.enquire_link_resp"><code class="name flex">
<span>async def <span class="ident">enquire_link_resp</span></span>(<span>self, sequence_number)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>HEADER</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<h1 id="enquire_link_resp-has-the-following-pdu-header">enquire_link_resp has the following pdu header:</h1>
<p>command_length, int, 4octet
command_id, int, 4octet. <code>enquire_link_resp</code>
command_status, int, 4octet. ESME_ROK (Success)
sequence_number, int, 4octet. Set to the same sequence number of original <code>enquire_link</code> PDU</p>
<p><code>enquire_link_resp</code> has no body.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def enquire_link_resp(self, sequence_number):
    &#34;&#34;&#34;
    HEADER::
    # enquire_link_resp has the following pdu header:
    command_length, int, 4octet
    command_id, int, 4octet. `enquire_link_resp`
    command_status, int, 4octet. ESME_ROK (Success)
    sequence_number, int, 4octet. Set to the same sequence number of original `enquire_link` PDU

    `enquire_link_resp` has no body.
    &#34;&#34;&#34;
    smpp_command = SmppCommand.ENQUIRE_LINK_RESP
    log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )

    # body
    body = b&#34;&#34;

    # header
    command_length = 16 + len(body)  # 16 is for headers
    command_id = self.command_ids[smpp_command]
    command_status = SmppCommandStatus.ESME_ROK.value
    sequence_number = sequence_number
    header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

    full_pdu = header + body
    item_to_enqueue = {
        &#34;version&#34;: self.naz_message_protocol_version,
        &#34;log_id&#34;: log_id,
        &#34;pdu&#34;: full_pdu,
        &#34;smpp_command&#34;: smpp_command,
    }
    try:
        await self.outboundqueue.enqueue(item_to_enqueue)
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;error&#34;: str(e),
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.enquire_link_resp&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.parse_response_pdu"><code class="name flex">
<span>async def <span class="ident">parse_response_pdu</span></span>(<span>self, pdu)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def parse_response_pdu(self, pdu):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    self.logger.info({&#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;, &#34;stage&#34;: &#34;start&#34;})

    header_data = pdu[:16]
    command_id_header_data = header_data[4:8]
    command_status_header_data = header_data[8:12]
    sequence_number_header_data = header_data[12:16]

    command_id = struct.unpack(&#34;&gt;I&#34;, command_id_header_data)[0]
    command_status = struct.unpack(&#34;&gt;I&#34;, command_status_header_data)[0]
    sequence_number = struct.unpack(&#34;&gt;I&#34;, sequence_number_header_data)[0]

    # get associated user supplied log_id if any
    try:
        log_id, hook_metadata = await self.correlation_handler.get(
            sequence_number=sequence_number
        )
    except Exception as e:
        log_id, hook_metadata = &#34;&#34;, &#34;&#34;
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: &#34;correlater get error&#34;,
                &#34;error&#34;: str(e),
            }
        )

    smpp_command = self.search_by_command_id_code(command_id)
    if not smpp_command:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: &#34;command_id:{0} is unknown.&#34;.format(command_id),
            }
        )
        raise ValueError(&#34;command_id:{0} is unknown.&#34;.format(command_id))

    await self.speficic_handlers(
        smpp_command=smpp_command,
        command_status_value=command_status,
        sequence_number=sequence_number,
        log_id=log_id,
        hook_metadata=hook_metadata,
    )
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.parse_response_pdu&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;smpp_command&#34;: smpp_command,
            &#34;log_id&#34;: log_id,
            &#34;command_status&#34;: command_status,
        }
    )}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.receive_data"><code class="name flex">
<span>async def <span class="ident">receive_data</span></span>(<span>self, TESTING=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def receive_data(self, TESTING=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    retry_count = 0
    while True:
        self.logger.info({&#34;event&#34;: &#34;naz.Client.receive_data&#34;, &#34;stage&#34;: &#34;start&#34;})
        # todo: look at `pause_reading` and `resume_reading` methods
        command_length_header_data = await self.reader.read(4)
        if command_length_header_data == b&#34;&#34;:
            retry_count += 1
            poll_read_interval = self.retry_after(retry_count)
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.receive_data&#34;,
                    &#34;stage&#34;: &#34;start&#34;,
                    &#34;state&#34;: &#34;no data received from SMSC. sleeping for {0}minutes&#34;.format(
                        poll_read_interval / 60
                    ),
                    &#34;retry_count&#34;: retry_count,
                }
            )
            await asyncio.sleep(poll_read_interval)
            continue
        else:
            # we didn&#39;t fail to read from SMSC
            retry_count = 0

        total_pdu_length = struct.unpack(&#34;&gt;I&#34;, command_length_header_data)[0]

        MSGLEN = total_pdu_length - 4
        chunks = []
        bytes_recd = 0
        while bytes_recd &lt; MSGLEN:
            chunk = await self.reader.read(min(MSGLEN - bytes_recd, 2048))
            if chunk == b&#34;&#34;:
                err = RuntimeError(&#34;socket connection broken&#34;)
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.receive_data&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;state&#34;: &#34;socket connection broken&#34;,
                        &#34;error&#34;: str(err),
                    }
                )
                raise err
            chunks.append(chunk)
            bytes_recd = bytes_recd + len(chunk)
        full_pdu_data = command_length_header_data + b&#34;&#34;.join(chunks)
        await self.parse_response_pdu(full_pdu_data)
        self.logger.info({&#34;event&#34;: &#34;naz.Client.receive_data&#34;, &#34;stage&#34;: &#34;end&#34;})
        if TESTING:
            # offer escape hatch for tests to come out of endless loop
            return full_pdu_data}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.search_by_command_id_code"><code class="name flex">
<span>def <span class="ident">search_by_command_id_code</span></span>(<span>self, command_id_code)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_by_command_id_code(self, command_id_code):
    for key, val in self.command_ids.items():
        if val == command_id_code:
            return key
    return None}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.send_data"><code class="name flex">
<span>async def <span class="ident">send_data</span></span>(<span>self, smpp_command, msg, log_id, hook_metadata=&#39;&#39;)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt>This method does not block; it buffers the data and arranges for it to be sent out asynchronously.</dt>
<dt><strong><code>see</code></strong> :&ensp;<code>https</code>://<a title="docs.python.org" href="/docs.python.org.ext"><code>docs.python.org</code></a>/<code>3</code>/<code>library</code>/<code>asyncio</code>-<a title="stream.html" href="/stream.html.ext"><code>stream.html</code></a>#<a title="asyncio.StreamWriter.write" href="/asyncio.StreamWriter.write.ext"><code>asyncio.StreamWriter.write</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def send_data(self, smpp_command, msg, log_id, hook_metadata=&#34;&#34;):
    &#34;&#34;&#34;
    This method does not block; it buffers the data and arranges for it to be sent out asynchronously.
    see: https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write
    &#34;&#34;&#34;
    # todo: look at `set_write_buffer_limits` and `get_write_buffer_limits` methods
    # print(&#34;get_write_buffer_limits:&#34;, writer.transport.get_write_buffer_limits())

    log_msg = &#34;&#34;
    try:
        log_msg = self.codec_class.decode(msg, self.encoding)
        # do not log password, redact it from logs.
        if self.password in log_msg:
            log_msg = log_msg.replace(self.password, &#34;{REDACTED}&#34;)
    except Exception:
        pass
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.send_data&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;smpp_command&#34;: smpp_command,
            &#34;log_id&#34;: log_id,
            &#34;msg&#34;: log_msg,
        }
    )

    # check session state to see if we can send messages.
    # see section 2.3 of SMPP spec document v3.4
    if self.current_session_state == SmppSessionState.CLOSED:
        error_msg = &#34;smpp_command: {0} cannot be sent to SMSC when the client session state is: {1}&#34;.format(
            smpp_command, self.current_session_state
        )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;msg&#34;: log_msg,
                &#34;current_session_state&#34;: self.current_session_state,
                &#34;error&#34;: error_msg,
            }
        )
        raise ValueError(error_msg)
    elif self.current_session_state == SmppSessionState.OPEN and smpp_command not in [
        &#34;bind_transmitter&#34;,
        &#34;bind_receiver&#34;,
        &#34;bind_transceiver&#34;,
    ]:
        # only the smpp_command&#39;s listed above are allowed by SMPP spec to be sent
        # if current_session_state == SmppSessionState.OPEN
        error_msg = &#34;smpp_command: {0} cannot be sent to SMSC when the client session state is: {1}&#34;.format(
            smpp_command, self.current_session_state
        )
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;msg&#34;: log_msg,
                &#34;current_session_state&#34;: self.current_session_state,
                &#34;error&#34;: error_msg,
            }
        )
        raise ValueError(error_msg)

    if isinstance(msg, str):
        msg = self.codec_class.encode(msg, self.encoding)

    # call user&#39;s hook for requests
    try:
        await self.hook.request(
            smpp_command=smpp_command, log_id=log_id, hook_metadata=hook_metadata
        )
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.send_data&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: &#34;request hook error&#34;,
                &#34;error&#34;: str(e),
            }
        )

    # We use writer.drain() which is a flow control method that interacts with the IO write buffer.
    # When the size of the buffer reaches the high watermark,
    # drain blocks until the size of the buffer is drained down to the low watermark and writing can be resumed.
    # When there is nothing to wait for, the drain() returns immediately.
    # ref: https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.drain
    self.writer.write(msg)
    await self.writer.drain()
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.send_data&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;smpp_command&#34;: smpp_command,
            &#34;log_id&#34;: log_id,
            &#34;msg&#34;: log_msg,
        }
    )}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.send_forever"><code class="name flex">
<span>async def <span class="ident">send_forever</span></span>(<span>self, TESTING=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def send_forever(self, TESTING=False):
    retry_count = 0
    while True:
        self.logger.info({&#34;event&#34;: &#34;naz.Client.send_forever&#34;, &#34;stage&#34;: &#34;start&#34;})

        # TODO: there are so many try-except classes in this func.
        # do something about that.
        try:
            # check with throttle handler
            send_request = await self.throttle_handler.allow_request()
        except Exception as e:
            self.logger.exception(
                {
                    &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;state&#34;: &#34;send_forever error&#34;,
                    &#34;error&#34;: str(e),
                }
            )
            continue
        if send_request:
            try:
                # rate limit ourselves
                await self.rateLimiter.limit()
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;state&#34;: &#34;send_forever error&#34;,
                        &#34;error&#34;: str(e),
                    }
                )
                continue

            try:
                item_to_dequeue = await self.outboundqueue.dequeue()
            except Exception as e:
                retry_count += 1
                poll_queue_interval = self.retry_after(retry_count)
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;state&#34;: &#34;send_forever error. sleeping for {0}minutes&#34;.format(
                            poll_queue_interval / 60
                        ),
                        &#34;retry_count&#34;: retry_count,
                        &#34;error&#34;: str(e),
                    }
                )
                await asyncio.sleep(poll_queue_interval)
                continue
            # we didn&#39;t fail to dequeue a message
            retry_count = 0
            try:
                log_id = item_to_dequeue[&#34;log_id&#34;]
                item_to_dequeue[&#34;version&#34;]  # version is a required field
                smpp_command = item_to_dequeue[&#34;smpp_command&#34;]
                hook_metadata = item_to_dequeue.get(&#34;hook_metadata&#34;, &#34;&#34;)
                if smpp_command == SmppCommand.SUBMIT_SM:
                    short_message = item_to_dequeue[&#34;short_message&#34;]
                    source_addr = item_to_dequeue[&#34;source_addr&#34;]
                    destination_addr = item_to_dequeue[&#34;destination_addr&#34;]
                    full_pdu = await self.build_submit_sm_pdu(
                        short_message, log_id, hook_metadata, source_addr, destination_addr
                    )
                else:
                    full_pdu = item_to_dequeue[&#34;pdu&#34;]
            except KeyError as e:
                e = KeyError(
                    &#34;enqueued message/object is missing required field:{}&#34;.format(str(e))
                )
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;state&#34;: &#34;send_forever error&#34;,
                        &#34;error&#34;: str(e),
                    }
                )
                continue

            await self.send_data(
                smpp_command=smpp_command,
                msg=full_pdu,
                log_id=log_id,
                hook_metadata=hook_metadata,
            )
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;log_id&#34;: log_id,
                    &#34;smpp_command&#34;: smpp_command,
                    &#34;send_request&#34;: send_request,
                }
            )
            if TESTING:
                # offer escape hatch for tests to come out of endless loop
                return item_to_dequeue
        else:
            # throttle_handler didn&#39;t allow us to send request.
            self.logger.info(
                {
                    &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                    &#34;stage&#34;: &#34;end&#34;,
                    &#34;send_request&#34;: send_request,
                }
            )
            try:
                await asyncio.sleep(await self.throttle_handler.throttle_delay())
            except Exception as e:
                self.logger.exception(
                    {
                        &#34;event&#34;: &#34;naz.Client.send_forever&#34;,
                        &#34;stage&#34;: &#34;end&#34;,
                        &#34;state&#34;: &#34;send_forever error&#34;,
                        &#34;error&#34;: str(e),
                    }
                )
                continue
            if TESTING:
                # offer escape hatch for tests to come out of endless loop
                return &#34;throttle_handler_denied_request&#34;
            continue}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.speficic_handlers"><code class="name flex">
<span>async def <span class="ident">speficic_handlers</span></span>(<span>self, smpp_command, command_status_value, sequence_number, log_id, hook_metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>this handles parsing speficic</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def speficic_handlers(
    self, smpp_command, command_status_value, sequence_number, log_id, hook_metadata
):
    &#34;&#34;&#34;
    this handles parsing speficic
    &#34;&#34;&#34;
    commandStatus = self.search_by_command_status_value(
        command_status_value=command_status_value
    )
    if not commandStatus:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;error&#34;: &#34;command_status:{0} is unknown.&#34;.format(command_status_value),
            }
        )
    elif commandStatus.value != SmppCommandStatus.ESME_ROK.value:
        # we got an error from SMSC
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;command_status&#34;: commandStatus.value,
                &#34;state&#34;: commandStatus.description,
            }
        )
    else:
        self.logger.info(
            {
                &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                &#34;stage&#34;: &#34;start&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;command_status&#34;: commandStatus.value,
                &#34;state&#34;: commandStatus.description,
            }
        )

    try:
        # call throttling handler
        if commandStatus.value == SmppCommandStatus.ESME_ROK.value:
            await self.throttle_handler.not_throttled()
        elif commandStatus.value == SmppCommandStatus.ESME_RTHROTTLED.value:
            await self.throttle_handler.throttled()
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;error&#34;: str(e),
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: commandStatus.description,
            }
        )

    if smpp_command in [
        SmppCommand.BIND_TRANSCEIVER,
        SmppCommand.UNBIND_RESP,
        SmppCommand.SUBMIT_SM,  # We dont expect SMSC to send `submit_sm` to us.
        SmppCommand.DELIVER_SM_RESP,
        # we will never send a deliver_sm request to SMSC, which means we never
        # have to handle deliver_sm_resp
        SmppCommand.ENQUIRE_LINK_RESP,
        SmppCommand.GENERIC_NACK,  # we can ignore this
    ]:
        # we never have to handle this
        pass
    elif smpp_command == SmppCommand.BIND_TRANSCEIVER_RESP:
        # the body of `bind_transceiver_resp` only has `system_id` which is a
        # C-Octet String of variable length upto 16 octets
        if commandStatus.value == SmppCommandStatus.ESME_ROK.value:
            self.current_session_state = SmppSessionState.BOUND_TRX
    elif smpp_command == SmppCommand.UNBIND:
        # we need to handle this since we need to send unbind_resp
        # it has no body
        await self.unbind_resp(sequence_number=sequence_number)
    elif smpp_command == SmppCommand.SUBMIT_SM_RESP:
        # the body of this only has `message_id` which is a C-Octet String of variable length upto 65 octets.
        # This field contains the SMSC message_id of the submitted message.
        # It may be used at a later stage to query the status of a message, cancel
        # or replace the message.
        pass
    elif smpp_command == SmppCommand.DELIVER_SM:
        # HEADER::
        # command_length, int, 4octet
        # command_id, int, 4octet. `deliver_sm`
        # command_status, int, 4octet. Unused, Set to NULL.
        # sequence_number, int, 4octet. The associated `deliver_sm_resp` PDU should echo the same sequence_number.

        # BODY::
        # see section 4.6.1 of smpp v3.4 spec
        # we want to handle this pdu, bcoz we are expected to send back deliver_sm_resp
        # the body of this has the following params
        # service_type, C-Octet String, max 6 octets
        # source_addr_ton, Int, 1 octet, can be NULL
        # source_addr_npi, Int, 1 octet, can be NULL
        # source_addr, C-Octet String, max 21 octet, can be NULL
        # dest_addr_ton, Int, 1 octet
        # dest_addr_npi, Int, 1 octet
        # destination_addr,  C-Octet String, max 21 octet
        # esm_class, Int, 1 octet
        # protocol_id, Int, 1 octet
        # priority_flag, Int, 1 octet
        # schedule_delivery_time, C-Octet String, 1 octet, must be set to NULL.
        # validity_period, C-Octet String, 1 octet, must be set to NULL.
        # registered_delivery, Int, 1 octet
        # replace_if_present_flag, Int, 1 octet, must be set to NULL.
        # data_coding, Int, 1 octet
        # sm_default_msg_id, Int, 1 octet, must be set to NULL.
        # sm_length, Int, 1 octet.It is length of short message user data in octets.
        # short_message, C-Octet String, 0-254 octet

        # NB: user&#39;s hook has already been called.
        await self.deliver_sm_resp(sequence_number=sequence_number)
    elif smpp_command == SmppCommand.ENQUIRE_LINK:
        # we have to handle this. we have to return enquire_link_resp
        # it has no body
        await self.enquire_link_resp(sequence_number=sequence_number)
    else:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;command_status&#34;: commandStatus.code,
                &#34;state&#34;: commandStatus.description,
                &#34;error&#34;: &#34;the smpp_command:{0} has not been implemented in naz. please create a github issue&#34;.format(
                    smpp_command
                ),
            }
        )

    # call user&#39;s hook for responses
    try:
        await self.hook.response(
            smpp_command=smpp_command,
            log_id=log_id,
            hook_metadata=hook_metadata,
            smsc_response=commandStatus,
        )
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.speficic_handlers&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: &#34;response hook error&#34;,
                &#34;error&#34;: str(e),
            }
        )}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.submit_sm"><code class="name flex">
<span>async def <span class="ident">submit_sm</span></span>(<span>self, short_message, log_id, source_addr, destination_addr)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>HEADER</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<h1 id="submit_sm-has-the-following-pdu-header">submit_sm has the following pdu header:</h1>
<p>command_length, int, 4octet
command_id, int, 4octet. <code>submit_sm</code>
command_status, int, 4octet. Not used. Set to NULL
sequence_number, int, 4octet.
The associated submit_sm_resp PDU will echo this sequence number.</p>
<dl>
<dt><strong><code>BODY</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<h1 id="submit_sm-has-the-following-pdu-body-nb-they-should-be-put-in-the-body-in-the-order-presented-here">submit_sm has the following pdu body. NB: They SHOULD be put in the body in the ORDER presented here.</h1>
<h1 id="service_type-c-octet-str-max-6octet-eg-null-ussd-cmt-etc">service_type, c-octet str, max 6octet. eg NULL, "USSD", "CMT" etc</h1>
<h1 id="source_addr_ton-int-1octet">source_addr_ton, int , 1octet,</h1>
<h1 id="source_addr_npi-int-1octet">source_addr_npi, int, 1octet</h1>
<h1 id="source_addr-c-octet-str-max-21octet-eg-this-is-usually-the-senders-phone-number">source_addr, c-octet str, max 21octet. eg; This is usually the senders phone Number</h1>
<h1 id="dest_addr_ton-int-1octet">dest_addr_ton, int, 1octet</h1>
<h1 id="dest_addr_npi-int-1octet">dest_addr_npi, int, 1octet</h1>
<h1 id="destination_addr-c-octet-string-max-21-octet-eg-this-is-usually-the-recipients-phone-number">destination_addr,
C-Octet String, max 21 octet. eg; This is usually the recipients phone Number</h1>
<h1 id="esm_class-int-1octet">esm_class, int, 1octet</h1>
<h1 id="protocol_id-int-1octet">protocol_id, int, 1octet</h1>
<h1 id="priority_flag-int-1octet">priority_flag, int, 1octet</h1>
<h1 id="schedule_delivery_time-c-octet-str-1-or-17-octets-null-for-immediate-message-delivery">schedule_delivery_time, c-octet str, 1 or 17 octets. NULL for immediate message delivery.</h1>
<h1 id="validity_period-c-octet-str-1-or-17-octets-null-for-smsc-default">validity_period, c-octet str, 1 or 17 octets.
NULL for SMSC default.</h1>
<h1 id="registered_delivery-int-1octet">registered_delivery, int, 1octet</h1>
<h1 id="replace_if_present_flag-int-1octet">replace_if_present_flag, int, 1octet</h1>
<h1 id="data_coding-int-1octet-defines-the-encoding-scheme-of-the-short-message-user-data-bits-7-6-5-4-3-2-1-0">data_coding, int, 1octet. Defines the encoding scheme of the short message user data. Bits 7 6 5 4 3 2 1 0</h1>
<h1 id="sm_default_msg_id-int-1octet-smsc-index-of-a-pre-definedcanned-message-if-not-using-an-smsc-canned-message-set-to-null">sm_default_msg_id, int, 1octet. SMSC index of a pre-defined(<code>canned</code>) message.
If not using an SMSC canned message, set to NULL</h1>
<h1 id="sm_length-int-1octet-length-in-octets-of-the-short_message">sm_length, int, 1octet. Length in octets of the <code>short_message</code>.</h1>
<h1 id="short_message-octet-stringnot-c-octet-str-0-254-octets">short_message, Octet-String(NOT c-octet str), 0-254 octets.</h1>
<p>NB: 1. Applications which need to send messages longer than 254 octets should use the <code>message_payload</code> optional parameter.
In this case the <code>sm_length</code> field should be set to zero
u cant use both <code>short_message</code> and <code>message_payload</code>
2. Octet String - A series of octets, not necessarily NULL terminated.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def submit_sm(self, short_message, log_id, source_addr, destination_addr):
    &#34;&#34;&#34;
    HEADER::
    # submit_sm has the following pdu header:
    command_length, int, 4octet
    command_id, int, 4octet. `submit_sm`
    command_status, int, 4octet. Not used. Set to NULL
    sequence_number, int, 4octet.  The associated submit_sm_resp PDU will echo this sequence number.

    BODY::
    # submit_sm has the following pdu body. NB: They SHOULD be put in the body in the ORDER presented here.
    # service_type, c-octet str, max 6octet. eg NULL, &#34;USSD&#34;, &#34;CMT&#34; etc
    # source_addr_ton, int , 1octet,
    # source_addr_npi, int, 1octet
    # source_addr, c-octet str, max 21octet. eg; This is usually the senders phone Number
    # dest_addr_ton, int, 1octet
    # dest_addr_npi, int, 1octet
    # destination_addr,  C-Octet String, max 21 octet. eg; This is usually the recipients phone Number
    # esm_class, int, 1octet
    # protocol_id, int, 1octet
    # priority_flag, int, 1octet
    # schedule_delivery_time, c-octet str, 1 or 17 octets. NULL for immediate message delivery.
    # validity_period, c-octet str, 1 or 17 octets.  NULL for SMSC default.
    # registered_delivery, int, 1octet
    # replace_if_present_flag, int, 1octet
    # data_coding, int, 1octet. Defines the encoding scheme of the short message user data. Bits 7 6 5 4 3 2 1 0
    # sm_default_msg_id, int, 1octet. SMSC index of a pre-defined(`canned`) message.  If not using an SMSC canned message, set to NULL
    # sm_length, int, 1octet. Length in octets of the `short_message`.
    # short_message, Octet-String(NOT c-octet str), 0-254 octets.
    NB: 1. Applications which need to send messages longer than 254 octets should use the `message_payload` optional parameter.
           In this case the `sm_length` field should be set to zero
           u cant use both `short_message` and `message_payload`
        2. Octet String - A series of octets, not necessarily NULL terminated.
    &#34;&#34;&#34;
    smpp_command = SmppCommand.SUBMIT_SM
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;log_id&#34;: log_id,
            &#34;short_message&#34;: short_message,
            &#34;source_addr&#34;: source_addr,
            &#34;destination_addr&#34;: destination_addr,
            &#34;smpp_command&#34;: smpp_command,
        }
    )
    item_to_enqueue = {
        &#34;version&#34;: self.naz_message_protocol_version,
        &#34;smpp_command&#34;: smpp_command,
        &#34;short_message&#34;: short_message,
        &#34;log_id&#34;: log_id,
        &#34;source_addr&#34;: source_addr,
        &#34;destination_addr&#34;: destination_addr,
    }
    try:
        await self.outboundqueue.enqueue(item_to_enqueue)
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;error&#34;: str(e),
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.submit_sm&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;log_id&#34;: log_id,
            &#34;short_message&#34;: short_message,
            &#34;source_addr&#34;: source_addr,
            &#34;destination_addr&#34;: destination_addr,
            &#34;smpp_command&#34;: smpp_command,
        }
    )}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.tranceiver_bind"><code class="name flex">
<span>async def <span class="ident">tranceiver_bind</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def tranceiver_bind(self):
    smpp_command = SmppCommand.BIND_TRANSCEIVER
    log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )
    # body
    body = b&#34;&#34;
    body = (
        body
        + self.codec_class.encode(self.system_id, self.encoding)
        + chr(0).encode()
        + self.codec_class.encode(self.password, self.encoding)
        + chr(0).encode()
        + self.codec_class.encode(self.system_type, self.encoding)
        + chr(0).encode()
        + struct.pack(&#34;&gt;I&#34;, self.interface_version)
        + struct.pack(&#34;&gt;I&#34;, self.addr_ton)
        + struct.pack(&#34;&gt;I&#34;, self.addr_npi)
        + self.codec_class.encode(self.address_range, self.encoding)
        + chr(0).encode()
    )

    # header
    command_length = 16 + len(body)  # 16 is for headers
    command_id = self.command_ids[smpp_command]
    # the status for success see section 5.1.3
    command_status = SmppCommandStatus.ESME_ROK.value
    try:
        sequence_number = self.sequence_generator.next_sequence()
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;error&#34;: str(e),
                &#34;smpp_command&#34;: smpp_command,
            }
        )

    if sequence_number &gt; self.max_sequence_number:
        # prevent third party sequence_generators from ruining our party
        raise ValueError(
            &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                sequence_number, self.max_sequence_number
            )
        )

    # associate sequence_number with log_id.
    # this will enable us to also associate responses and thus enhancing traceability of all workflows
    try:
        await self.correlation_handler.put(
            sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
        )
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: &#34;correlater put error&#34;,
                &#34;error&#34;: str(e),
            }
        )

    header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
    full_pdu = header + body
    await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.tranceiver_bind&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )
    return full_pdu}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.unbind"><code class="name flex">
<span>async def <span class="ident">unbind</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>HEADER</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<h1 id="unbind-has-the-following-pdu-header">unbind has the following pdu header:</h1>
<p>command_length, int, 4octet
command_id, int, 4octet. <code>unbind</code>
command_status, int, 4octet. Not used. Set to NULL
sequence_number, int, 4octet.</p>
<p><code>unbind</code> has no body.</p>
<p>clients/users should call this method when winding down.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def unbind(self):
    &#34;&#34;&#34;
    HEADER::
    # unbind has the following pdu header:
    command_length, int, 4octet
    command_id, int, 4octet. `unbind`
    command_status, int, 4octet. Not used. Set to NULL
    sequence_number, int, 4octet.

    `unbind` has no body.

    clients/users should call this method when winding down.
    &#34;&#34;&#34;
    smpp_command = SmppCommand.UNBIND
    log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.unbind&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )
    # body
    body = b&#34;&#34;

    # header
    command_length = 16 + len(body)  # 16 is for headers
    command_id = self.command_ids[smpp_command]
    command_status = 0x00000000  # not used for `unbind`
    try:
        sequence_number = self.sequence_generator.next_sequence()
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;error&#34;: str(e),
                &#34;log_id&#34;: log_id,
                &#34;smpp_command&#34;: smpp_command,
            }
        )
    if sequence_number &gt; self.max_sequence_number:
        # prevent third party sequence_generators from ruining our party
        raise ValueError(
            &#34;the sequence_number: {0} is greater than the max: {1} allowed by SMPP spec.&#34;.format(
                sequence_number, self.max_sequence_number
            )
        )

    try:
        await self.correlation_handler.put(
            sequence_number=sequence_number, log_id=log_id, hook_metadata=&#34;&#34;
        )
    except Exception as e:
        self.logger.exception(
            {
                &#34;event&#34;: &#34;naz.Client.unbind&#34;,
                &#34;stage&#34;: &#34;end&#34;,
                &#34;smpp_command&#34;: smpp_command,
                &#34;log_id&#34;: log_id,
                &#34;state&#34;: &#34;correlater put error&#34;,
                &#34;error&#34;: str(e),
            }
        )

    header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)
    full_pdu = header + body
    # dont queue unbind in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
    await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.unbind&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )}</code></pre>
</details>
</dd>
<dt id="naz.client.Client.unbind_resp"><code class="name flex">
<span>async def <span class="ident">unbind_resp</span></span>(<span>self, sequence_number)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>HEADER</code></strong> :&ensp;:</dt>
<dd>&nbsp;</dd>
</dl>
<h1 id="unbind_resp-has-the-following-pdu-header">unbind_resp has the following pdu header:</h1>
<p>command_length, int, 4octet
command_id, int, 4octet. <code>unbind_resp</code>
command_status, int, 4octet. Indicates outcome of original unbind request, eg ESME_ROK (Success)
sequence_number, int, 4octet. Set to the same sequence number of original <code>unbind</code> PDU</p>
<p><code>unbind_resp</code> has no body.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">async def unbind_resp(self, sequence_number):
    &#34;&#34;&#34;
    HEADER::
    # unbind_resp has the following pdu header:
    command_length, int, 4octet
    command_id, int, 4octet. `unbind_resp`
    command_status, int, 4octet. Indicates outcome of original unbind request, eg ESME_ROK (Success)
    sequence_number, int, 4octet. Set to the same sequence number of original `unbind` PDU

    `unbind_resp` has no body.
    &#34;&#34;&#34;
    smpp_command = SmppCommand.UNBIND_RESP
    log_id = &#34;&#34;.join(random.choices(string.ascii_lowercase + string.digits, k=17))
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.unbind_resp&#34;,
            &#34;stage&#34;: &#34;start&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )

    # body
    body = b&#34;&#34;

    # header
    command_length = 16 + len(body)  # 16 is for headers
    command_id = self.command_ids[smpp_command]
    command_status = SmppCommandStatus.ESME_ROK.value
    sequence_number = sequence_number
    header = struct.pack(&#34;&gt;IIII&#34;, command_length, command_id, command_status, sequence_number)

    full_pdu = header + body
    # dont queue unbind_resp in SimpleOutboundQueue since we dont want it to be behind 10k msgs etc
    await self.send_data(smpp_command=smpp_command, msg=full_pdu, log_id=log_id)
    self.logger.info(
        {
            &#34;event&#34;: &#34;naz.Client.unbind_resp&#34;,
            &#34;stage&#34;: &#34;end&#34;,
            &#34;log_id&#34;: log_id,
            &#34;smpp_command&#34;: smpp_command,
        }
    )}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="naz.client.CommandStatus"><code class="flex name class">
<span>class <span class="ident">CommandStatus</span></span>
<span>(</span><span><small>ancestors:</small> <a title="builtins.tuple" href="/builtins.tuple.ext">builtins.tuple</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>CommandStatus(code, value, description)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CommandStatus(typing.NamedTuple):
    code: str
    value: int
    description: str}</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="naz.client.CommandStatus.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="naz.client.CommandStatus.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="naz.client.CommandStatus.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="naz.client.DataCoding"><code class="flex name class">
<span>class <span class="ident">DataCoding</span></span>
<span>(</span><span><small>ancestors:</small> <a title="builtins.tuple" href="/builtins.tuple.ext">builtins.tuple</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>DataCoding(code, value, description)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DataCoding(typing.NamedTuple):
    code: str
    value: int
    description: str}</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="naz.client.DataCoding.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="naz.client.DataCoding.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="naz.client.DataCoding.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
</dl>
</dd>
<dt id="naz.client.NazLoggingAdapter"><code class="flex name class">
<span>class <span class="ident">NazLoggingAdapter</span></span>
<span>(</span><span><small>ancestors:</small> <a title="logging.LoggerAdapter" href="/logging.LoggerAdapter.ext">logging.LoggerAdapter</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>This example adapter expects the passed in dict-like object to have a
'log_metadata' key, whose value in brackets is apended to the log message.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NazLoggingAdapter(logging.LoggerAdapter):
    &#34;&#34;&#34;
    This example adapter expects the passed in dict-like object to have a
    &#39;log_metadata&#39; key, whose value in brackets is apended to the log message.
    &#34;&#34;&#34;

    def process(self, msg, kwargs):
        if isinstance(msg, str):
            return msg, kwargs
        else:
            log_metadata = self.extra.get(&#34;log_metadata&#34;)
            merged_log_event = {**msg, **log_metadata}
            return &#34;{0}&#34;.format(merged_log_event), kwargs}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="naz.client.NazLoggingAdapter.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, msg, kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Process the logging message and keyword arguments passed in to
a logging call to insert contextual information. You can either
manipulate the message itself, the keyword args or both. Return
the message and kwargs modified (or not) to suit your needs.</p>
<p>Normally, you'll only need to override this one method in a
LoggerAdapter subclass for your specific needs.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def process(self, msg, kwargs):
    if isinstance(msg, str):
        return msg, kwargs
    else:
        log_metadata = self.extra.get(&#34;log_metadata&#34;)
        merged_log_event = {**msg, **log_metadata}
        return &#34;{0}&#34;.format(merged_log_event), kwargs}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="naz.client.SmppCommand"><code class="flex name class">
<span>class <span class="ident">SmppCommand</span></span>
</code></dt>
<dd>
<section class="desc"><p>see section 4 of SMPP spec document v3.4</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SmppCommand:
    &#34;&#34;&#34;
    see section 4 of SMPP spec document v3.4
    &#34;&#34;&#34;

    BIND_TRANSCEIVER = &#34;bind_transceiver&#34;
    BIND_TRANSCEIVER_RESP = &#34;bind_transceiver_resp&#34;
    UNBIND = &#34;unbind&#34;
    UNBIND_RESP = &#34;unbind_resp&#34;
    SUBMIT_SM = &#34;submit_sm&#34;
    SUBMIT_SM_RESP = &#34;submit_sm_resp&#34;
    DELIVER_SM = &#34;deliver_sm&#34;
    DELIVER_SM_RESP = &#34;deliver_sm_resp&#34;
    ENQUIRE_LINK = &#34;enquire_link&#34;
    ENQUIRE_LINK_RESP = &#34;enquire_link_resp&#34;
    GENERIC_NACK = &#34;generic_nack&#34;}</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="naz.client.SmppCommand.BIND_TRANSCEIVER"><code class="name">var <span class="ident">BIND_TRANSCEIVER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.BIND_TRANSCEIVER_RESP"><code class="name">var <span class="ident">BIND_TRANSCEIVER_RESP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.DELIVER_SM"><code class="name">var <span class="ident">DELIVER_SM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.DELIVER_SM_RESP"><code class="name">var <span class="ident">DELIVER_SM_RESP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.ENQUIRE_LINK"><code class="name">var <span class="ident">ENQUIRE_LINK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.ENQUIRE_LINK_RESP"><code class="name">var <span class="ident">ENQUIRE_LINK_RESP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.GENERIC_NACK"><code class="name">var <span class="ident">GENERIC_NACK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.SUBMIT_SM"><code class="name">var <span class="ident">SUBMIT_SM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.SUBMIT_SM_RESP"><code class="name">var <span class="ident">SUBMIT_SM_RESP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.UNBIND"><code class="name">var <span class="ident">UNBIND</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommand.UNBIND_RESP"><code class="name">var <span class="ident">UNBIND_RESP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="naz.client.SmppCommandStatus"><code class="flex name class">
<span>class <span class="ident">SmppCommandStatus</span></span>
</code></dt>
<dd>
<section class="desc"><p>see section 5.1.3 of smpp ver 3.4 spec document</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SmppCommandStatus:
    &#34;&#34;&#34;
    see section 5.1.3 of smpp ver 3.4 spec document
    &#34;&#34;&#34;

    ESME_ROK = CommandStatus(code=&#34;ESME_ROK&#34;, value=0x00000000, description=&#34;Success&#34;)
    ESME_RINVMSGLEN = CommandStatus(
        code=&#34;ESME_RINVMSGLEN&#34;, value=0x00000001, description=&#34;Message Length is invalid&#34;
    )
    ESME_RINVCMDLEN = CommandStatus(
        code=&#34;ESME_RINVCMDLEN&#34;, value=0x00000002, description=&#34;Command Length is invalid&#34;
    )
    ESME_RINVCMDID = CommandStatus(
        code=&#34;ESME_RINVCMDID&#34;, value=0x00000003, description=&#34;Invalid Command ID&#34;
    )
    ESME_RINVBNDSTS = CommandStatus(
        code=&#34;ESME_RINVBNDSTS&#34;,
        value=0x00000004,
        description=&#34;Incorrect BIND Status for given command&#34;,
    )
    ESME_RALYBND = CommandStatus(
        code=&#34;ESME_RALYBND&#34;, value=0x00000005, description=&#34;ESME Already in Bound State&#34;
    )
    ESME_RINVPRTFLG = CommandStatus(
        code=&#34;ESME_RINVPRTFLG&#34;, value=0x00000006, description=&#34;Invalid Priority Flag&#34;
    )
    ESME_RINVREGDLVFLG = CommandStatus(
        code=&#34;ESME_RINVREGDLVFLG&#34;, value=0x00000007, description=&#34;Invalid Registered Delivery Flag&#34;
    )
    ESME_RSYSERR = CommandStatus(code=&#34;ESME_RSYSERR&#34;, value=0x00000008, description=&#34;System Error&#34;)
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000009,description= &#34;Reserved&#34;)
    ESME_RINVSRCADR = CommandStatus(
        code=&#34;ESME_RINVSRCADR&#34;, value=0x0000000A, description=&#34;Invalid Source Address&#34;
    )
    ESME_RINVDSTADR = CommandStatus(
        code=&#34;ESME_RINVDSTADR&#34;, value=0x0000000B, description=&#34;Invalid Dest Addr&#34;
    )
    ESME_RINVMSGID = CommandStatus(
        code=&#34;ESME_RINVMSGID&#34;, value=0x0000000C, description=&#34;Message ID is invalid&#34;
    )
    ESME_RBINDFAIL = CommandStatus(
        code=&#34;ESME_RBINDFAIL&#34;, value=0x0000000D, description=&#34;Bind Failed&#34;
    )
    ESME_RINVPASWD = CommandStatus(
        code=&#34;ESME_RINVPASWD&#34;, value=0x0000000E, description=&#34;Invalid Password&#34;
    )
    ESME_RINVSYSID = CommandStatus(
        code=&#34;ESME_RINVSYSID&#34;, value=0x0000000F, description=&#34;Invalid System ID&#34;
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000010,description= &#34;Reserved&#34;)
    ESME_RCANCELFAIL = CommandStatus(
        code=&#34;ESME_RCANCELFAIL&#34;, value=0x00000011, description=&#34;Cancel SM Failed&#34;
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000012,description= &#34;Reserved&#34;)
    ESME_RREPLACEFAIL = CommandStatus(
        code=&#34;ESME_RREPLACEFAIL&#34;, value=0x00000013, description=&#34;Replace SM Failed&#34;
    )
    ESME_RMSGQFUL = CommandStatus(
        code=&#34;ESME_RMSGQFUL&#34;, value=0x00000014, description=&#34;Message Queue Full&#34;
    )
    ESME_RINVSERTYP = CommandStatus(
        code=&#34;ESME_RINVSERTYP&#34;, value=0x00000015, description=&#34;Invalid Service Type&#34;
    )
    # Reserved 0x00000016 - 0x00000032 Reserved
    ESME_RINVNUMDESTS = CommandStatus(
        code=&#34;ESME_RINVNUMDESTS&#34;, value=0x00000033, description=&#34;Invalid number of destinations&#34;
    )
    ESME_RINVDLNAME = CommandStatus(
        code=&#34;ESME_RINVNUMDESTS&#34;, value=0x00000034, description=&#34;Invalid Distribution List name&#34;
    )
    # Reserved 0x00000035 - 0x0000003F Reserved
    ESME_RINVDESTFLAG = CommandStatus(
        code=&#34;ESME_RINVDESTFLAG&#34;,
        value=0x00000040,
        description=&#34;Destination flag is invalid (submit_multi)&#34;,
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000041,description= &#34;Reserved&#34;)
    ESME_RINVSUBREP = CommandStatus(
        code=&#34;ESME_RINVSUBREP&#34;,
        value=0x00000042,
        description=&#34;Invalid (submit with replace) request(i.e. submit_sm with replace_if_present_flag set)&#34;,
    )
    ESME_RINVESMCLASS = CommandStatus(
        code=&#34;ESME_RINVESMCLASS&#34;, value=0x00000043, description=&#34;Invalid esm_class field data&#34;
    )
    ESME_RCNTSUBDL = CommandStatus(
        code=&#34;ESME_RCNTSUBDL&#34;, value=0x00000044, description=&#34;Cannot Submit to Distribution List&#34;
    )
    ESME_RSUBMITFAIL = CommandStatus(
        code=&#34;ESME_RSUBMITFAIL&#34;, value=0x00000045, description=&#34;Submit_sm or submit_multi failed&#34;
    )
    # Reserved 0x00000046 - 0x00000047 Reserved
    ESME_RINVSRCTON = CommandStatus(
        code=&#34;ESME_RINVSRCTON&#34;, value=0x00000048, description=&#34;Invalid Source address TON&#34;
    )
    ESME_RINVSRCNPI = CommandStatus(
        code=&#34;ESME_RINVSRCNPI&#34;, value=0x00000049, description=&#34;Invalid Source address NPI&#34;
    )
    ESME_RINVDSTTON = CommandStatus(
        code=&#34;ESME_RINVDSTTON&#34;, value=0x00000050, description=&#34;Invalid Destination address TON&#34;
    )
    ESME_RINVDSTNPI = CommandStatus(
        code=&#34;ESME_RINVDSTNPI&#34;, value=0x00000051, description=&#34;Invalid Destination address NPI&#34;
    )
    # Reserved =  CommandStatus(code=&#34;Reserved&#34;, value=0x00000052,description= &#34;Reserved&#34;)
    ESME_RINVSYSTYP = CommandStatus(
        code=&#34;ESME_RINVSYSTYP&#34;, value=0x00000053, description=&#34;Invalid system_type field&#34;
    )
    ESME_RINVREPFLAG = CommandStatus(
        code=&#34;ESME_RINVREPFLAG&#34;, value=0x00000054, description=&#34;Invalid replace_if_present flag&#34;
    )
    ESME_RINVNUMMSGS = CommandStatus(
        code=&#34;ESME_RINVNUMMSGS&#34;, value=0x00000055, description=&#34;Invalid number of messages&#34;
    )
    # Reserved 0x00000056 - 0x00000057 Reserved
    ESME_RTHROTTLED = CommandStatus(
        code=&#34;ESME_RTHROTTLED&#34;,
        value=0x00000058,
        description=&#34;Throttling error (ESME has exceeded allowed message limits)&#34;,
    )
    # Reserved 0x00000059 - 0x00000060 Reserved
    ESME_RINVSCHED = CommandStatus(
        code=&#34;ESME_RINVSCHED&#34;, value=0x00000061, description=&#34;Invalid Scheduled Delivery Time&#34;
    )
    ESME_RINVEXPIRY = CommandStatus(
        code=&#34;ESME_RINVEXPIRY&#34;,
        value=0x00000062,
        description=&#34;Invalid message validity period (Expiry time)&#34;,
    )
    ESME_RINVDFTMSGID = CommandStatus(
        code=&#34;ESME_RINVDFTMSGID&#34;,
        value=0x00000063,
        description=&#34;Predefined Message Invalid or Not Found&#34;,
    )
    ESME_RX_T_APPN = CommandStatus(
        code=&#34;ESME_RX_T_APPN&#34;,
        value=0x00000064,
        description=&#34;ESME Receiver Temporary App Error Code&#34;,
    )
    ESME_RX_P_APPN = CommandStatus(
        code=&#34;ESME_RX_P_APPN&#34;,
        value=0x00000065,
        description=&#34;ESME Receiver Permanent App Error Code&#34;,
    )
    ESME_RX_R_APPN = CommandStatus(
        code=&#34;ESME_RX_R_APPN&#34;,
        value=0x00000066,
        description=&#34;ESME Receiver Reject Message Error Code&#34;,
    )
    ESME_RQUERYFAIL = CommandStatus(
        code=&#34;ESME_RQUERYFAIL&#34;, value=0x00000067, description=&#34;query_sm request failed&#34;
    )
    # Reserved 0x00000068 - 0x000000BF Reserved
    ESME_RINVOPTPARSTREAM = CommandStatus(
        code=&#34;ESME_RINVOPTPARSTREAM&#34;,
        value=0x000000C0,
        description=&#34;Error in the optional part of the PDU Body.&#34;,
    )
    ESME_ROPTPARNOTALLWD = CommandStatus(
        code=&#34;ESME_ROPTPARNOTALLWD&#34;, value=0x000000C1, description=&#34;Optional Parameter not allowed&#34;
    )
    ESME_RINVPARLEN = CommandStatus(
        code=&#34;ESME_RINVPARLEN&#34;, value=0x000000C2, description=&#34;Invalid Parameter Length.&#34;
    )
    ESME_RMISSINGOPTPARAM = CommandStatus(
        code=&#34;ESME_RMISSINGOPTPARAM&#34;,
        value=0x000000C3,
        description=&#34;Expected Optional Parameter missing&#34;,
    )
    ESME_RINVOPTPARAMVAL = CommandStatus(
        code=&#34;ESME_RINVOPTPARAMVAL&#34;,
        value=0x000000C4,
        description=&#34;Invalid Optional Parameter Value&#34;,
    )
    # Reserved 0x000000C5 - 0x000000FD Reserved
    ESME_RDELIVERYFAILURE = CommandStatus(
        code=&#34;ESME_RDELIVERYFAILURE&#34;,
        value=0x000000FE,
        description=&#34;Delivery Failure (used for data_sm_resp)&#34;,
    )
    ESME_RUNKNOWNERR = CommandStatus(
        code=&#34;ESME_RUNKNOWNERR&#34;, value=0x000000FF, description=&#34;Unknown Error&#34;
    )}</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="naz.client.SmppCommandStatus.ESME_RALYBND"><code class="name">var <span class="ident">ESME_RALYBND</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RBINDFAIL"><code class="name">var <span class="ident">ESME_RBINDFAIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RCANCELFAIL"><code class="name">var <span class="ident">ESME_RCANCELFAIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RCNTSUBDL"><code class="name">var <span class="ident">ESME_RCNTSUBDL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RDELIVERYFAILURE"><code class="name">var <span class="ident">ESME_RDELIVERYFAILURE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVBNDSTS"><code class="name">var <span class="ident">ESME_RINVBNDSTS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVCMDID"><code class="name">var <span class="ident">ESME_RINVCMDID</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVCMDLEN"><code class="name">var <span class="ident">ESME_RINVCMDLEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVDESTFLAG"><code class="name">var <span class="ident">ESME_RINVDESTFLAG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVDFTMSGID"><code class="name">var <span class="ident">ESME_RINVDFTMSGID</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVDLNAME"><code class="name">var <span class="ident">ESME_RINVDLNAME</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVDSTADR"><code class="name">var <span class="ident">ESME_RINVDSTADR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVDSTNPI"><code class="name">var <span class="ident">ESME_RINVDSTNPI</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVDSTTON"><code class="name">var <span class="ident">ESME_RINVDSTTON</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVESMCLASS"><code class="name">var <span class="ident">ESME_RINVESMCLASS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVEXPIRY"><code class="name">var <span class="ident">ESME_RINVEXPIRY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVMSGID"><code class="name">var <span class="ident">ESME_RINVMSGID</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVMSGLEN"><code class="name">var <span class="ident">ESME_RINVMSGLEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVNUMDESTS"><code class="name">var <span class="ident">ESME_RINVNUMDESTS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVNUMMSGS"><code class="name">var <span class="ident">ESME_RINVNUMMSGS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVOPTPARAMVAL"><code class="name">var <span class="ident">ESME_RINVOPTPARAMVAL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVOPTPARSTREAM"><code class="name">var <span class="ident">ESME_RINVOPTPARSTREAM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVPARLEN"><code class="name">var <span class="ident">ESME_RINVPARLEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVPASWD"><code class="name">var <span class="ident">ESME_RINVPASWD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVPRTFLG"><code class="name">var <span class="ident">ESME_RINVPRTFLG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVREGDLVFLG"><code class="name">var <span class="ident">ESME_RINVREGDLVFLG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVREPFLAG"><code class="name">var <span class="ident">ESME_RINVREPFLAG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSCHED"><code class="name">var <span class="ident">ESME_RINVSCHED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSERTYP"><code class="name">var <span class="ident">ESME_RINVSERTYP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSRCADR"><code class="name">var <span class="ident">ESME_RINVSRCADR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSRCNPI"><code class="name">var <span class="ident">ESME_RINVSRCNPI</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSRCTON"><code class="name">var <span class="ident">ESME_RINVSRCTON</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSUBREP"><code class="name">var <span class="ident">ESME_RINVSUBREP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSYSID"><code class="name">var <span class="ident">ESME_RINVSYSID</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RINVSYSTYP"><code class="name">var <span class="ident">ESME_RINVSYSTYP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RMISSINGOPTPARAM"><code class="name">var <span class="ident">ESME_RMISSINGOPTPARAM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RMSGQFUL"><code class="name">var <span class="ident">ESME_RMSGQFUL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_ROK"><code class="name">var <span class="ident">ESME_ROK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_ROPTPARNOTALLWD"><code class="name">var <span class="ident">ESME_ROPTPARNOTALLWD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RQUERYFAIL"><code class="name">var <span class="ident">ESME_RQUERYFAIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RREPLACEFAIL"><code class="name">var <span class="ident">ESME_RREPLACEFAIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RSUBMITFAIL"><code class="name">var <span class="ident">ESME_RSUBMITFAIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RSYSERR"><code class="name">var <span class="ident">ESME_RSYSERR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RTHROTTLED"><code class="name">var <span class="ident">ESME_RTHROTTLED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RUNKNOWNERR"><code class="name">var <span class="ident">ESME_RUNKNOWNERR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RX_P_APPN"><code class="name">var <span class="ident">ESME_RX_P_APPN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RX_R_APPN"><code class="name">var <span class="ident">ESME_RX_R_APPN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppCommandStatus.ESME_RX_T_APPN"><code class="name">var <span class="ident">ESME_RX_T_APPN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="naz.client.SmppDataCoding"><code class="flex name class">
<span>class <span class="ident">SmppDataCoding</span></span>
</code></dt>
<dd>
<section class="desc"><p>see section 5.2.19 of smpp ver 3.4 spec document.
also see:
1. https://github.com/praekelt/vumi/blob/767eac623c81cc4b2e6ea9fbd6a3645f121ef0aa/vumi/transports/smpp/processors/default.py#L260
2. https://docs.python.org/3/library/codecs.html
3. https://docs.python.org/3/library/codecs.html#standard-encodings</p>
<p>The attributes of this class are equivalent to some of the names found in the python standard-encodings documentation
ie; https://docs.python.org/3/library/codecs.html#standard-encodings</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SmppDataCoding:
    &#34;&#34;&#34;
    see section 5.2.19 of smpp ver 3.4 spec document.
    also see:
      1. https://github.com/praekelt/vumi/blob/767eac623c81cc4b2e6ea9fbd6a3645f121ef0aa/vumi/transports/smpp/processors/default.py#L260
      2. https://docs.python.org/3/library/codecs.html
      3. https://docs.python.org/3/library/codecs.html#standard-encodings

    The attributes of this class are equivalent to some of the names found in the python standard-encodings documentation
    ie; https://docs.python.org/3/library/codecs.html#standard-encodings
    &#34;&#34;&#34;

    gsm0338 = DataCoding(code=&#34;gsm0338&#34;, value=0b00000000, description=&#34;SMSC Default Alphabet&#34;)
    ascii = DataCoding(
        code=&#34;ascii&#34;, value=0b00000001, description=&#34;IA5(CCITT T.50) / ASCII(ANSI X3.4)&#34;
    )
    octet_unspecified_I = DataCoding(
        code=&#34;octet_unspecified_I&#34;,
        value=0b00000010,
        description=&#34;Octet unspecified(8 - bit binary)&#34;,
    )
    latin_1 = DataCoding(code=&#34;latin_1&#34;, value=0b00000011, description=&#34;Latin 1 (ISO - 8859 - 1)&#34;)
    octet_unspecified_II = DataCoding(
        code=&#34;octet_unspecified_II&#34;,
        value=0b00000100,
        description=&#34;Octet unspecified(8 - bit binary)&#34;,
    )
    # iso2022_jp, iso2022jp and iso-2022-jp are aliases
    # see: https://stackoverflow.com/a/43240579/2768067
    iso2022_jp = DataCoding(code=&#34;iso2022_jp&#34;, value=0b00000101, description=&#34;JIS(X 0208 - 1990)&#34;)
    iso8859_5 = DataCoding(
        code=&#34;iso8859_5&#34;, value=0b00000110, description=&#34;Cyrllic(ISO - 8859 - 5)&#34;
    )
    iso8859_8 = DataCoding(
        code=&#34;iso8859_8&#34;, value=0b00000111, description=&#34;Latin / Hebrew(ISO - 8859 - 8)&#34;
    )
    # see: https://stackoverflow.com/a/14488478/2768067
    utf_16_be = DataCoding(
        code=&#34;utf_16_be&#34;, value=0b00001000, description=&#34;UCS2(ISO / IEC - 10646)&#34;
    )
    ucs2 = DataCoding(code=&#34;ucs2&#34;, value=0b00001000, description=&#34;UCS2(ISO / IEC - 10646)&#34;)
    shift_jis = DataCoding(code=&#34;shift_jis&#34;, value=0b00001001, description=&#34;Pictogram Encoding&#34;)
    iso2022jp = DataCoding(
        code=&#34;iso2022jp&#34;, value=0b00001010, description=&#34;ISO - 2022 - JP(Music Codes)&#34;
    )
    # reservedI= DataCoding(code=&#34;reservedI&#34;, value=0b00001011, description= &#34;reserved&#34;)
    # reservedII= DataCoding(code=&#34;reservedII&#34;, value=0b00001100, description= &#34;reserved&#34;)
    euc_kr = DataCoding(code=&#34;euc_kr&#34;, value=0b00001110, description=&#34;KS C 5601&#34;)}</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="naz.client.SmppDataCoding.ascii"><code class="name">var <span class="ident">ascii</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.euc_kr"><code class="name">var <span class="ident">euc_kr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.gsm0338"><code class="name">var <span class="ident">gsm0338</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.iso2022_jp"><code class="name">var <span class="ident">iso2022_jp</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.iso2022jp"><code class="name">var <span class="ident">iso2022jp</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.iso8859_5"><code class="name">var <span class="ident">iso8859_5</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.iso8859_8"><code class="name">var <span class="ident">iso8859_8</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.latin_1"><code class="name">var <span class="ident">latin_1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.octet_unspecified_I"><code class="name">var <span class="ident">octet_unspecified_I</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.octet_unspecified_II"><code class="name">var <span class="ident">octet_unspecified_II</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.shift_jis"><code class="name">var <span class="ident">shift_jis</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.ucs2"><code class="name">var <span class="ident">ucs2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppDataCoding.utf_16_be"><code class="name">var <span class="ident">utf_16_be</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="naz.client.SmppSessionState"><code class="flex name class">
<span>class <span class="ident">SmppSessionState</span></span>
</code></dt>
<dd>
<section class="desc"><p>see section 2.2 of SMPP spec document v3.4
we are ignoring the other states since we are only concerning ourselves with an ESME in Transceiver mode.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SmppSessionState:
    &#34;&#34;&#34;
    see section 2.2 of SMPP spec document v3.4
    we are ignoring the other states since we are only concerning ourselves with an ESME in Transceiver mode.
    &#34;&#34;&#34;

    # An ESME has established a network connection to the SMSC but has not yet issued a Bind request.
    OPEN = &#34;OPEN&#34;
    # A connected ESME has requested to bind as an ESME Transceiver (by issuing a bind_transceiver PDU)
    # and has received a response from the SMSC authorising its Bind request.
    BOUND_TRX = &#34;BOUND_TRX&#34;
    # An ESME has unbound from the SMSC and has closed the network connection. The SMSC may also unbind from the ESME.
    CLOSED = &#34;CLOSED&#34;}</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="naz.client.SmppSessionState.BOUND_TRX"><code class="name">var <span class="ident">BOUND_TRX</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppSessionState.CLOSED"><code class="name">var <span class="ident">CLOSED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="naz.client.SmppSessionState.OPEN"><code class="name">var <span class="ident">OPEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="naz" href="index.html">naz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="naz.client.Client" href="#naz.client.Client">Client</a></code></h4>
<ul class="two-column">
<li><code><a title="naz.client.Client.__init__" href="#naz.client.Client.__init__">__init__</a></code></li>
<li><code><a title="naz.client.Client.build_submit_sm_pdu" href="#naz.client.Client.build_submit_sm_pdu">build_submit_sm_pdu</a></code></li>
<li><code><a title="naz.client.Client.connect" href="#naz.client.Client.connect">connect</a></code></li>
<li><code><a title="naz.client.Client.deliver_sm_resp" href="#naz.client.Client.deliver_sm_resp">deliver_sm_resp</a></code></li>
<li><code><a title="naz.client.Client.enquire_link" href="#naz.client.Client.enquire_link">enquire_link</a></code></li>
<li><code><a title="naz.client.Client.enquire_link_resp" href="#naz.client.Client.enquire_link_resp">enquire_link_resp</a></code></li>
<li><code><a title="naz.client.Client.find_data_coding" href="#naz.client.Client.find_data_coding">find_data_coding</a></code></li>
<li><code><a title="naz.client.Client.parse_response_pdu" href="#naz.client.Client.parse_response_pdu">parse_response_pdu</a></code></li>
<li><code><a title="naz.client.Client.receive_data" href="#naz.client.Client.receive_data">receive_data</a></code></li>
<li><code><a title="naz.client.Client.retry_after" href="#naz.client.Client.retry_after">retry_after</a></code></li>
<li><code><a title="naz.client.Client.search_by_command_id_code" href="#naz.client.Client.search_by_command_id_code">search_by_command_id_code</a></code></li>
<li><code><a title="naz.client.Client.search_by_command_status_value" href="#naz.client.Client.search_by_command_status_value">search_by_command_status_value</a></code></li>
<li><code><a title="naz.client.Client.send_data" href="#naz.client.Client.send_data">send_data</a></code></li>
<li><code><a title="naz.client.Client.send_forever" href="#naz.client.Client.send_forever">send_forever</a></code></li>
<li><code><a title="naz.client.Client.speficic_handlers" href="#naz.client.Client.speficic_handlers">speficic_handlers</a></code></li>
<li><code><a title="naz.client.Client.submit_sm" href="#naz.client.Client.submit_sm">submit_sm</a></code></li>
<li><code><a title="naz.client.Client.tranceiver_bind" href="#naz.client.Client.tranceiver_bind">tranceiver_bind</a></code></li>
<li><code><a title="naz.client.Client.unbind" href="#naz.client.Client.unbind">unbind</a></code></li>
<li><code><a title="naz.client.Client.unbind_resp" href="#naz.client.Client.unbind_resp">unbind_resp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="naz.client.CommandStatus" href="#naz.client.CommandStatus">CommandStatus</a></code></h4>
<ul class="">
<li><code><a title="naz.client.CommandStatus.code" href="#naz.client.CommandStatus.code">code</a></code></li>
<li><code><a title="naz.client.CommandStatus.description" href="#naz.client.CommandStatus.description">description</a></code></li>
<li><code><a title="naz.client.CommandStatus.value" href="#naz.client.CommandStatus.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="naz.client.DataCoding" href="#naz.client.DataCoding">DataCoding</a></code></h4>
<ul class="">
<li><code><a title="naz.client.DataCoding.code" href="#naz.client.DataCoding.code">code</a></code></li>
<li><code><a title="naz.client.DataCoding.description" href="#naz.client.DataCoding.description">description</a></code></li>
<li><code><a title="naz.client.DataCoding.value" href="#naz.client.DataCoding.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="naz.client.NazLoggingAdapter" href="#naz.client.NazLoggingAdapter">NazLoggingAdapter</a></code></h4>
<ul class="">
<li><code><a title="naz.client.NazLoggingAdapter.process" href="#naz.client.NazLoggingAdapter.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="naz.client.SmppCommand" href="#naz.client.SmppCommand">SmppCommand</a></code></h4>
<ul class="two-column">
<li><code><a title="naz.client.SmppCommand.BIND_TRANSCEIVER" href="#naz.client.SmppCommand.BIND_TRANSCEIVER">BIND_TRANSCEIVER</a></code></li>
<li><code><a title="naz.client.SmppCommand.BIND_TRANSCEIVER_RESP" href="#naz.client.SmppCommand.BIND_TRANSCEIVER_RESP">BIND_TRANSCEIVER_RESP</a></code></li>
<li><code><a title="naz.client.SmppCommand.DELIVER_SM" href="#naz.client.SmppCommand.DELIVER_SM">DELIVER_SM</a></code></li>
<li><code><a title="naz.client.SmppCommand.DELIVER_SM_RESP" href="#naz.client.SmppCommand.DELIVER_SM_RESP">DELIVER_SM_RESP</a></code></li>
<li><code><a title="naz.client.SmppCommand.ENQUIRE_LINK" href="#naz.client.SmppCommand.ENQUIRE_LINK">ENQUIRE_LINK</a></code></li>
<li><code><a title="naz.client.SmppCommand.ENQUIRE_LINK_RESP" href="#naz.client.SmppCommand.ENQUIRE_LINK_RESP">ENQUIRE_LINK_RESP</a></code></li>
<li><code><a title="naz.client.SmppCommand.GENERIC_NACK" href="#naz.client.SmppCommand.GENERIC_NACK">GENERIC_NACK</a></code></li>
<li><code><a title="naz.client.SmppCommand.SUBMIT_SM" href="#naz.client.SmppCommand.SUBMIT_SM">SUBMIT_SM</a></code></li>
<li><code><a title="naz.client.SmppCommand.SUBMIT_SM_RESP" href="#naz.client.SmppCommand.SUBMIT_SM_RESP">SUBMIT_SM_RESP</a></code></li>
<li><code><a title="naz.client.SmppCommand.UNBIND" href="#naz.client.SmppCommand.UNBIND">UNBIND</a></code></li>
<li><code><a title="naz.client.SmppCommand.UNBIND_RESP" href="#naz.client.SmppCommand.UNBIND_RESP">UNBIND_RESP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="naz.client.SmppCommandStatus" href="#naz.client.SmppCommandStatus">SmppCommandStatus</a></code></h4>
<ul class="two-column">
<li><code><a title="naz.client.SmppCommandStatus.ESME_RALYBND" href="#naz.client.SmppCommandStatus.ESME_RALYBND">ESME_RALYBND</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RBINDFAIL" href="#naz.client.SmppCommandStatus.ESME_RBINDFAIL">ESME_RBINDFAIL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RCANCELFAIL" href="#naz.client.SmppCommandStatus.ESME_RCANCELFAIL">ESME_RCANCELFAIL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RCNTSUBDL" href="#naz.client.SmppCommandStatus.ESME_RCNTSUBDL">ESME_RCNTSUBDL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RDELIVERYFAILURE" href="#naz.client.SmppCommandStatus.ESME_RDELIVERYFAILURE">ESME_RDELIVERYFAILURE</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVBNDSTS" href="#naz.client.SmppCommandStatus.ESME_RINVBNDSTS">ESME_RINVBNDSTS</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVCMDID" href="#naz.client.SmppCommandStatus.ESME_RINVCMDID">ESME_RINVCMDID</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVCMDLEN" href="#naz.client.SmppCommandStatus.ESME_RINVCMDLEN">ESME_RINVCMDLEN</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVDESTFLAG" href="#naz.client.SmppCommandStatus.ESME_RINVDESTFLAG">ESME_RINVDESTFLAG</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVDFTMSGID" href="#naz.client.SmppCommandStatus.ESME_RINVDFTMSGID">ESME_RINVDFTMSGID</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVDLNAME" href="#naz.client.SmppCommandStatus.ESME_RINVDLNAME">ESME_RINVDLNAME</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVDSTADR" href="#naz.client.SmppCommandStatus.ESME_RINVDSTADR">ESME_RINVDSTADR</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVDSTNPI" href="#naz.client.SmppCommandStatus.ESME_RINVDSTNPI">ESME_RINVDSTNPI</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVDSTTON" href="#naz.client.SmppCommandStatus.ESME_RINVDSTTON">ESME_RINVDSTTON</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVESMCLASS" href="#naz.client.SmppCommandStatus.ESME_RINVESMCLASS">ESME_RINVESMCLASS</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVEXPIRY" href="#naz.client.SmppCommandStatus.ESME_RINVEXPIRY">ESME_RINVEXPIRY</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVMSGID" href="#naz.client.SmppCommandStatus.ESME_RINVMSGID">ESME_RINVMSGID</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVMSGLEN" href="#naz.client.SmppCommandStatus.ESME_RINVMSGLEN">ESME_RINVMSGLEN</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVNUMDESTS" href="#naz.client.SmppCommandStatus.ESME_RINVNUMDESTS">ESME_RINVNUMDESTS</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVNUMMSGS" href="#naz.client.SmppCommandStatus.ESME_RINVNUMMSGS">ESME_RINVNUMMSGS</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVOPTPARAMVAL" href="#naz.client.SmppCommandStatus.ESME_RINVOPTPARAMVAL">ESME_RINVOPTPARAMVAL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVOPTPARSTREAM" href="#naz.client.SmppCommandStatus.ESME_RINVOPTPARSTREAM">ESME_RINVOPTPARSTREAM</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVPARLEN" href="#naz.client.SmppCommandStatus.ESME_RINVPARLEN">ESME_RINVPARLEN</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVPASWD" href="#naz.client.SmppCommandStatus.ESME_RINVPASWD">ESME_RINVPASWD</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVPRTFLG" href="#naz.client.SmppCommandStatus.ESME_RINVPRTFLG">ESME_RINVPRTFLG</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVREGDLVFLG" href="#naz.client.SmppCommandStatus.ESME_RINVREGDLVFLG">ESME_RINVREGDLVFLG</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVREPFLAG" href="#naz.client.SmppCommandStatus.ESME_RINVREPFLAG">ESME_RINVREPFLAG</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSCHED" href="#naz.client.SmppCommandStatus.ESME_RINVSCHED">ESME_RINVSCHED</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSERTYP" href="#naz.client.SmppCommandStatus.ESME_RINVSERTYP">ESME_RINVSERTYP</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSRCADR" href="#naz.client.SmppCommandStatus.ESME_RINVSRCADR">ESME_RINVSRCADR</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSRCNPI" href="#naz.client.SmppCommandStatus.ESME_RINVSRCNPI">ESME_RINVSRCNPI</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSRCTON" href="#naz.client.SmppCommandStatus.ESME_RINVSRCTON">ESME_RINVSRCTON</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSUBREP" href="#naz.client.SmppCommandStatus.ESME_RINVSUBREP">ESME_RINVSUBREP</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSYSID" href="#naz.client.SmppCommandStatus.ESME_RINVSYSID">ESME_RINVSYSID</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RINVSYSTYP" href="#naz.client.SmppCommandStatus.ESME_RINVSYSTYP">ESME_RINVSYSTYP</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RMISSINGOPTPARAM" href="#naz.client.SmppCommandStatus.ESME_RMISSINGOPTPARAM">ESME_RMISSINGOPTPARAM</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RMSGQFUL" href="#naz.client.SmppCommandStatus.ESME_RMSGQFUL">ESME_RMSGQFUL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_ROK" href="#naz.client.SmppCommandStatus.ESME_ROK">ESME_ROK</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_ROPTPARNOTALLWD" href="#naz.client.SmppCommandStatus.ESME_ROPTPARNOTALLWD">ESME_ROPTPARNOTALLWD</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RQUERYFAIL" href="#naz.client.SmppCommandStatus.ESME_RQUERYFAIL">ESME_RQUERYFAIL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RREPLACEFAIL" href="#naz.client.SmppCommandStatus.ESME_RREPLACEFAIL">ESME_RREPLACEFAIL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RSUBMITFAIL" href="#naz.client.SmppCommandStatus.ESME_RSUBMITFAIL">ESME_RSUBMITFAIL</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RSYSERR" href="#naz.client.SmppCommandStatus.ESME_RSYSERR">ESME_RSYSERR</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RTHROTTLED" href="#naz.client.SmppCommandStatus.ESME_RTHROTTLED">ESME_RTHROTTLED</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RUNKNOWNERR" href="#naz.client.SmppCommandStatus.ESME_RUNKNOWNERR">ESME_RUNKNOWNERR</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RX_P_APPN" href="#naz.client.SmppCommandStatus.ESME_RX_P_APPN">ESME_RX_P_APPN</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RX_R_APPN" href="#naz.client.SmppCommandStatus.ESME_RX_R_APPN">ESME_RX_R_APPN</a></code></li>
<li><code><a title="naz.client.SmppCommandStatus.ESME_RX_T_APPN" href="#naz.client.SmppCommandStatus.ESME_RX_T_APPN">ESME_RX_T_APPN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="naz.client.SmppDataCoding" href="#naz.client.SmppDataCoding">SmppDataCoding</a></code></h4>
<ul class="two-column">
<li><code><a title="naz.client.SmppDataCoding.ascii" href="#naz.client.SmppDataCoding.ascii">ascii</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.euc_kr" href="#naz.client.SmppDataCoding.euc_kr">euc_kr</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.gsm0338" href="#naz.client.SmppDataCoding.gsm0338">gsm0338</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.iso2022_jp" href="#naz.client.SmppDataCoding.iso2022_jp">iso2022_jp</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.iso2022jp" href="#naz.client.SmppDataCoding.iso2022jp">iso2022jp</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.iso8859_5" href="#naz.client.SmppDataCoding.iso8859_5">iso8859_5</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.iso8859_8" href="#naz.client.SmppDataCoding.iso8859_8">iso8859_8</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.latin_1" href="#naz.client.SmppDataCoding.latin_1">latin_1</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.octet_unspecified_I" href="#naz.client.SmppDataCoding.octet_unspecified_I">octet_unspecified_I</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.octet_unspecified_II" href="#naz.client.SmppDataCoding.octet_unspecified_II">octet_unspecified_II</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.shift_jis" href="#naz.client.SmppDataCoding.shift_jis">shift_jis</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.ucs2" href="#naz.client.SmppDataCoding.ucs2">ucs2</a></code></li>
<li><code><a title="naz.client.SmppDataCoding.utf_16_be" href="#naz.client.SmppDataCoding.utf_16_be">utf_16_be</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="naz.client.SmppSessionState" href="#naz.client.SmppSessionState">SmppSessionState</a></code></h4>
<ul class="">
<li><code><a title="naz.client.SmppSessionState.BOUND_TRX" href="#naz.client.SmppSessionState.BOUND_TRX">BOUND_TRX</a></code></li>
<li><code><a title="naz.client.SmppSessionState.CLOSED" href="#naz.client.SmppSessionState.CLOSED">CLOSED</a></code></li>
<li><code><a title="naz.client.SmppSessionState.OPEN" href="#naz.client.SmppSessionState.OPEN">OPEN</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>